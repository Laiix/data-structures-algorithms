package com.eussi.ch14_weighted_graph;

import com.eussi.ch14_weighted_graph.util.Graph;
import com.eussi.ch14_weighted_graph.util.GraphD;
import com.eussi.util.PrintUtil;

import static com.eussi.util.PrintUtil.*;

/**
 * @author wangxueming
 * @create 2020-03-09 19:25
 * @description
 */
public class GraphWApp {
    /**
     * 带权图
     *      在前一章己经看到了图的边可以有方向。本章中，将要探讨边的另一个特性：权值。例如，
     * 如果带权图的顶点代表城市，边的权可能代表城市间的距离，或者城市间的飞行费用，或者两城
     * 市间每年的汽车流量（高速公路建设者往往对这个感兴趣）。
     *      当把权值当作边的特性时，一些有趣和复杂的问题也就出现了。什么是带权图的最小生成树？
     * 什么是两个顶点间的最短（或造价最低）距离？这些问题在现实世界中有重要的意义。
     *      首先来看有权的无向图以及它的最小生成树。在本章后半部分，将讨论带有方向和权值的图，
     * 同时探讨著名的Dijkstra算法，并利用它寻找两点间的最短路径。
     */

    public static void main(String[] args) {
        /**
         * 带权图的最小生成树
         *      要引入带权图，首先回到最小生成树的问题。在有向图中创建这样一棵树比在无向图中
         * 要复杂一点。当所有的边拥有相同的权值，问题变得简单了（正如第13章中看到的），算法可
         * 以任意选择一条边加入最小生成树。但是当边具有不同的权值时，需要用一些算法策略来选择
         * 正确的边。
         *
         * 一个实例：丛林中的有线电视
         *      假设要在一个虚拟的国家Magnaguena的6个城市之间架有线电视网，把它们都连接起来。
         * 五条边可以连接六个点，但是应该是哪五条边呢？连接每两个城市的造价不同，所以必须仔细
         * 选择线路使得总体造价最低。
         *                            10
         *                       B  --——-    C       六个顶点两两相连，线的方向代表连接点，线上数字代表权重
         *                  6/   | 7\    /  |  \6
         *                A     7|   \ /   |     F
         *                  4\   |  8/\   5|    /7
         *                    \  | /   \   |  /
         *                      D  ——---   E
         *                           12
         *
         *      上图显示了一个有6个顶点的带权图，代表6个城市，A、B、C、D、E和F。每条边有一个
         * 权值，标记在边的旁边。假设这些数字代表在两城市间架设电缆的造价，1 代表一百万元。
         * （注意，由于地形原因会导致距离太远，所以一些边是不必要的；例如，假设从A到C或从D到F
         * 距离太远，所以这些边不予考虑，也没有出现在图中。）
         *      选择哪些边架设电缆，能使得安装有线电视系统的造价最低呢？答案是利用最小生成树。
         * 它将有五条边（比城市的数量少1)，连接六个城市，并具有建立连接所需的最小代价。通过看
         * 上图，能否直接找出这些边呢？
         *      通过算法可以看出如下最小生成树：
         *                        B       C
         *                   6/   7\      | \6
         *                A         \   5|    F
         *                   4\      \   |
         *                      D      E
         * 派遣调查员
         *      构造最小生成树的算法有些棘手，为了介绍这个算法先引入一个有线电视雇员的例子。现
         * 在有一个雇员（当然是经理）和一些调查员。
         *      计算机算法（除非它可能是神经网络）不能一次“知道”给定问题的所有数据：它不能处理
         * 全面的大图，只能一点一点地得到数据，随着处理过程的深入，不断修改问题的结果。对于图来
         * 说，算法从某个顶点开始工作，首先得到这个点附近的数据，然后找到更远顶点的数据。在前面
         * 一章，深度优先捜索和广度优先搜索就是同样的例子。
         *      同样，假设开始不知道任意两个城市安装电缆需要多少钱。得到这些数据需要时间。这时
         * 就需要调査员。
         *  - 从A开始
         *      现在从在A建立办事处开始（可以在任意一个城市开始，但是A有最好的餐馆）。从只能到
         * 两个城市：B和D(参考上图）。雇佣两个强壮且熟悉丛林环境的调查员，把他们派到危险的荒野
         * 中去，一个前往B, 一个前往D。这个工作是为了确定在这两条路线上安装有线电视的造价。
         *      第一个调査员到达了 B,完成了他的调査，他通知总部说在A和B之间安装电缆要六百万。
         * 第二个调查员遇到了鳄鱼，晚些时候从D报告，A到D的电缆穿过更多的村庄，却只要四百万。现
         * 在得到一个表单：
         *      A-D, $4,000,000
         *      A-B, $6,000,000
         *      然后按价值大小抹序：很快将会看到为什么这是一个好方法。
         *  - 建立A-D的连接
         *      这时，可以正式派出建筑队安装从A到D的电缆。如何确定A-D一线最终是造价是最低方案
         * （最小生成树）的一部分？因为迄今为止，只知道整个系统的两条连线。难道不需要其他的信息
         * 了吗？
         *      为了对这个情况有一个直观感受.试想有其他的连接比当前从A到D的连接更省钱。如果它
         * 不是直接连接D,那么它必定是绕过B,然后 迂回到D,可能会穿过一个或更多的城市。但是现在己
         * 经知道到B的连接需要六百万，比到D的连接（4百万）更加昂贵。所以假设有其余可想像的路线
         * 更廉价，但是因为穿过了B而导致那些路线的造价比与D直接连接还要高，并且经过B到达环线上
         * 的其他城市比从D经过要昂贵。
         *      所以结论就是A-D是最小生成树的一部分。这里虽没有进行形式化的证明（证明超出本书
         * 范围），但是它确实表明选择目前造价最低的路线是最好的作法。所以应该安装从A到D的电缆，
         * 并在D建办事处。
         *      为什么需要办事处？这是该国政府的要求，在从一个城市派出调査员到邻近的城市前，必
         * 须在这个城市建办事处。用图的术语说，在得到某个顶点与之相连的边的权值前，必须把顶点加
         * 入到树中。有办事处的城市都用电缆彼此连接，没有办事处的城市都还没有连接。
         *  - 建立A-B的连接
         *      现在己经完成了 A-D的连接，并且在D修建了办事处，可以从D派出调查员去能够到达的城
         * 市，分别是B、C和E。调査员到达各自的终点.并报告三条连接的造价，分别为7百万、8百万和
         * 1千2百万。（当然，不需要派调査员去A,因为己经调查了它们之间的路线，并安装了电缆现在已
         * 经知道了从有办事处的城市到没有办是处的城市的4条路线，分别是:
         *      A-B, $6,000,000
         *      D-B, $7,000,000
         *      D-C, $8,000,000
         *      D-E, $12,000,000
         *      为什么A-D这条线路不在表单中？因为那里己经安装了电缆；没有必要对它作进一步的考虑，
         * 所以己经安装的路线一律从表单中删除。
         *      现在，接着做什么不是很明显。有许多潜在的路线可供选择。哪一条是最佳选择呢？下面是
         * 规则：
         *      “在表单中，总是选择造价最低的边”
         *      实际上，刚才在选择从A出发的线路时，已经使用了这个规则：A-D是造价最低的。这时，造
         * 价最低的边是A-B，所以花费6百万安装从A到B的电缆，并在B建办事处。
         *      在这里暂停一下，做个小结。在某个特定时间，电缆系统构造过程中，有三类城市：
         *       - 己经有办事处，并且用电缆连接的城市。（在图中，它们是最小生成树的顶点。）
         *       - 还没有连接，也没有办事处的城市，但是己知把它们连接到至少一个已有办事处的城市
         *       电缆的安装造价。这些城市叫做“边缘”城市。
         *       - 还不知道任何信息的城市。
         *      这样的话，A，D和B属于第一类，C和E属于第二类，而F属于第三类。随着算法的不断进行，
         * 城市从第三类变成第二类，再变成第一类。
         *  - 建立B-E的连接
         *      目前，A、D和B已接入电缆系统，也有了办事处。现在己经知道从A和D到第二类城市的造价，
         * 而不知道从B到第二类城市的造价，所以需要从B派遣调查员到C和E。他们报告说连接C需要1千万，
         * 连接E需要7百万。下面是新的表单：
         *      B-E, $7,000,000
         *      D-C, $8,000,000
         *      B-C, $10,000,000
         *      D-E, $12,000,000
         *      注意，D-B的连接原来在表单中，现在却没有了，因为没有必要考虑己连接的城市之间的连
         * 接问趣，即使它们不是直接相连的。
         *      从这个表单中可以看到，造价最低的路线是B-E,需要7百万，所以修建了这段电缆，并在E
         * 建立办事处。
         *  - 建立E-C的连接
         *      从E, 调查员报告连接C需要5百万，连接F需要7百万。D-E的连接必须从表单中删除，因为E
         * 现在是一个己连接的城市。新的表单是
         *      E-C, $5,000,000
         *      E-F, $7,000,000
         *      D-C, $8,000,000
         *      B-C, 10,000,000
         *      造价最低的连接是E-C,所以修建这条连接，并在C建立办事处。
         *  - 最后建立C-F的连接
         *      选择的范围现在变窄了，除去所有己经连接的城市，表单上只有两项：
         *      C-F, $6,000,000
         *      E-F, $7,000,000
         *      安装从C到F的电缆，在F建立办事处后，所有工作就完成了。由于每个城市都有了办事处，
         * 所以工作肯定完成了。建立的电缆路线是A-D、A-B、B-E、E-C和C-F，如上图最小生成树，这是
         * 连接六个城市造价最低的方案。
         *
         * 设计算法
         *      这个想像中安装有线电视系统的例子，己经阐释了寻找带权图最小生成树算法的主要思想。
         * 现在看一下如何根据这个过程设计算法。
         *
         * 优先级队列
         *      正如前面例子描述的那样，执行算法的关键行为是保存两城市间建立连接的造价表。通过
         * 选择造价最低的项，就可以决定下一条连接建在何处。
         *      建议用优先级队列来实现这个用于反复选择最小造价值的表，而不用链表或数组。这是解
         * 决最小生成树的有效方式。在正式的程序中，优先级队列可能基于堆来实现，正如第12章“堆’’
         * 所描述的。这会加快在较大的优先级队列中的操作。然而，在实例程序中，将用数组实现优先级
         * 队列。
         *
         * 算法要点
         *      下面用图的术语（相对于有线电视的术语）重申一下算法：
         *      从一个顶点开始，把它放入树的集合中。然后重复做下面的事情：
         *          1.找到从最新的顶点到其他顶点的所有边，这些顶点不能在树的集合中。把这些边放
         *          入优先级队列。
         *          2.找出权值最小的边，把它和它所到达的顶点放入树的集合中。
         *      重复这些步骤，直到所有顶点都在树的集合中。这时，工作完成。
         *      在步骤1, “最新的”意味着最近放入树中的。此步骤的边可以在邻接矩阵中找到。步骤1完
         * 成后，表中包含了所有的边，这些边都是从树中顶点到它们的不在树中的邻接点（边缘点）的连接，
         *
         * 无用边
         *      在表剩余条目中，想要把某些连接删除比较困难，它们都是从当前城市到已经拥有办事处的城
         * 市的连接。但是如果不做这个工作，就可能会导致安装不必要的有线电缆。
         *      在程序的算法中，也要确保优先级队列中不能有连接己在树中的顶点的边。每次向树中增加顶
         * 点后，都要遍历优先级队列査找并删除这样的边。这样做了以后，要使优先级队列中在任意时刻只保
         * 持一条从树中顶点到某边缘点的边就变得容易了。也就是说，优先级队列中应该只包含一条到达某个
         * 第二类顶点的边。
         *
         * 步骤表
         *      下表显示了步骤：
         *      步骤  没剪除的边列表     减除边列表(在优先级队列中)  优先级队列中因重复删掉的边
         *      1     AB6,AD4           AB6,AD4
         *      2     DE12,DC8,DB7,AB6  DE12,DE8,AB6             DB7(AB6)
         *      3     DE12,BC10,DC8,BE7 DC8,BE7                  DE12(BE7),BC10(DC8)
         *      4     BC10,DC8,EF7,EC5  EF7,EC5                  BC10(EC5),DC8(EC5)
         *      5     EF7,CF6           CF6                      EF7
         *      记住，一条边包含源（起始）点的字母，汇（结束）点的字母和权值。表中的第二列对应构造
         * 有线电视系统时的表。它显示了从第一类顶点（已在树中的顶点）到第二类顶点（至少有一条边与第
         * 一类顶点相连）的边。
         *      第三列是运行算法时，优先级队列的变化情况。任何与其他边有相同终点的边，如果权值较大，
         * 就从队列中刪除。
         *      第四列显示了已经被删除的边，括号中是权值较小的边，它取代了权值较大的边，保留在队列中。
         * 记住，在步进执行的过程中，表中最后一项肯定要被删除，因为它己经加到树中。
         *
         * 在优先级队列中寻找目的地重复的边
         *      如何保证以每个第二类顶点为目的地的边只有一条？每次向树中增加边的时候，一定要确保没
         * 有其他边也到达同样的顶点。如果有，只保留最小权值的边。
         *      这使得在优先级队列中逐项査找成为必要的一步操作。査找的目的是看是否有这样的重复边。
         * 优先级队列设计初衷本不为随机访问的，所以这不是一个有效的方法。然而，在这种情况下，必须违
         * 反一下优先级队列的设计思想。
         */
        mstw(); // minimum spanning tree weighted
        sep();

        /**
         *      算法在while循环中执行，循环结束条件是所有顶点都己在树中。循环中完成下面的操作：
         *          1.当前顶点放在树中。
         *          2.连接这个顶点的边放到优先级队列中（如果合适）。
         *          3.从优先级队列中删除权值最小的边。这条边的目的顶点变成当前顶点。
         *      再看看这些步骤的细节。在步骤1中，通过标记currentVert所指顶点的isInTree字段来表示该
         * 顶点放入树中。
         *      在步骤2中，连接这个顶点的边插入优先级队列。通过在邻接矩阵中扫描行号是currentVert的
         * 行寻找需要的边。只要下面任意一个条件为真，这条边就不能放入队列中：
         *          • 源点和终点相同。
         *          • 终点在树中。
         *          • 源点和终点之间没有边（邻接矩阵中对应的值等于无限大）。
         *      如果没有一个条件为真，调用putInPQ()方法把这条边放入队列中。实际上，正如下面要看到的，
         * 这个例程并不总把边放到队列中。
         *      在步骤3中，将最小权值的边从优先级队列中删除。把这条边和该边的终点加入树，并显示源点
         * （currentVert)和终点。
         *      在mstw()方法最后，所有顶点的isInTree变量被重置，即从树中删除。在该程序中这样做，是
         * 因为根据这些数据只能创建一棵树。然而，在完成一项工作后，最好把数据恢复到原始的形态。
         *      正如前面所强调的，在优先级队列中应该只含有一条到达某个特定目标顶点的边。putInPQ()方
         * 法保证了这一点。它调用PriorityQ类的find()方法，这个方法经过修正，可以寻找到达指定点的边。
         * 如果不存在到达指定点的边，find()方法返回一1，这时putInPQ()方法只要把新边插入优先级队列中
         * 即可。然而，如果有到达指定点的老边存在，putInPQ()方法就要检査老边是否比新边有更小的权值。
         * 如果老边的权值小，就不需要作什么变化。如果新边有更小的权值，就要把老边从队列中删除，把新边
         * 放进去。
         */

        /**
         * 最短路径问题
         *      可能在带权图中最常遇到的问题就是，寻找两点间的最短路径问题。这个问题的解决方法可应用
         * 于现实生活中的很多情况，从印刷电路板的布局到项目调度都适用。但是它比前面见到的问题更复杂一
         * 些，所以首先还是来看一个真实世界的场景，它还发生在前面一节引入的虚拟的Magnaguena
         * 国。
         *
         * 铁路线
         *      这次需要考虑铁路线而不是有线电视系统。然而，这个项目不像上一个那么浩大。这次并不是要
         * 修建铁路；铁路已经存在了。这次只是想找到从一个城市到另一个城市的费用最低的路线。
         *
         *                              60
         *                         B     →      C
         *                50↗       ↖50    ↗20
         *              A        90↓     /      ↓40
         *                80↘        /      \
         *                         D      →     E
         *                               70
         *
         *
         *      旅客在两个城市间搭乘火车需要固定的费用。上图显示了这些费用。也就是说，从A到B需要50元，
         * 从B到D需要90元，等等。费用与两城市间的铁路长度无关（这不同于现在飞机费用的情况）。
         *      上图的边是有向的。它们代表铁路是单向的， (为了安全）火车只允许朝一个方向开。例如，可
         * 以坐火车从A到B，但是反过来不行。
         *      不管怎样，最关心的还是路费便宜。在图论中，这类问题叫做最短路径问题（SPP shortest path
         * problem)。这里所说的最短并不总是指距离上的最短：它也可以代表最便宜，最快或最好的路径，或其
         * 他衡量标准。
         *
         * 最便宜的费用
         *      任何两个城市间都有几条可能的路线。例如，为了从A到达E,可以通过D，或通过 B和C,也可以通
         * 过D和C,还可以选择其他的路线。（现在不可能通过火车到达F,因为要经过崎岖的山脉，所以在图中没有
         * 显示。这是比较幸运的，因为缩小了要解决的问题的规模。）
         *      最短路径问题是这样的：对一个给定的源点和终止点，走哪条路线费用最低？在上图中，能够看出
         *（需要费些精力）从A到E费用最低的路线是通过D和C;它只需要花费140元。
         *
         * 有向带权图
         *      正如前面提到的，铁路线只有一个方向，所以火车在任何两个城市间只能朝一个方向行进。这相当
         * 于一个有向图。本来应该描绘一个更接近现实的情况，即乘客可以花同样的钱在两个城市间往返。那就相
         * 当一个无向图。然而最短路径问题在这两种情况下是类似的。所以为了体现多样性，我们来看这个问题在
         * 有向图中如何解决。
         *
         * Dijkstra 算法
         *      为解决最短路径问题而提出的方法叫做Djikstra算法，Edsger Dijkstra在1959年首次解决了这
         * 个问题。这个算法的实现基于图的邻接矩阵表示法。让人感到有些惊奇的是它不仅能够找到任意两点间的
         * 最短路径，还可以找到某个指定点到其他所有顶点的最短路径。
         *
         * 代理人和铁路路线
         *      为了了解Dijkstra算法如何工作，假设需要找到从A到Magnaguena所有其他城市的费用最低的路线。
         * 这里要有扮演计算机程序的角色来执行Dijkstra算法（雇佣的代理人也是如此)。当然，现实中可以得到一
         * 本关于所有铁路费用的说明。然而算法在任意时刻只能看到一条信息，所以（如前面章节所示）假定不能直
         * 接看到整个图的样子。
         *      在每个城市，站长会吿知从该站到可以直达的其他城市的费用（即单段铁路，不包括穿过其他城市的
         * 铁路）。而且，他不能告知从该站跨过一个以上的城市到达另一个城市的费用。这里需要用到一个记事本，
         * 本子上为每个城市留一列的位置，并且希望每列的最后显示从源点到其他城市的最低费用路线。
         *  - 第一个代理人：在A
         *      最终，需要在每个城市放一个代理人：这个代理人的工作是保持到其他城市费用的信息。你自己是A的
         * 代理人。
         *      A的站长所能告诉你的是到B需要50元，到D需要80元，把这些记在本子上，如下表：
         *          从A到         B           C           D            E
         *          step1       50(via A)    inf         80(via A)    inf
         *      表中“inf”是“无穷大”的缩写，意味着不能从A到达表中每一列的列头所示的城市，或者至少目前为止
         * 不知道如何到达那里。（在算法中，用一个非常大的数代表无穷大。将会看到，这有助于进行计算。）圆括
         * 号中的内容显示了在到达不同的目的地之前，最后访问的城市。待会将看到为什么要有这个信息。现在将要
         * 做什么？下面是必须遵循的规则：
         *      规则
         *          总是把代理人派到下一个城市，从源点（A)到这个城市的费用最小。
         *      不必考虑那些己经有代理人的城市。注意，这个规则和最小生成树中问题（安装有线电视系统） 的规
         * 则不同。****在那个问题中，需要找到从已连接城市到未连接城市的造价最低连接(边）。在这个问题中，需
         * 要找到从A到没有代理人的城市的最低费用路线。****在这个研究项目的特殊情况下，两者做同样的事情，因
         * 为所有从A出发的路线只包含一条边，但是，当把代理人派到更多城市时，从A出发的路线会变成几条有向边的和。
         *  - 第二个代理人：在B
         *      从A出发的费用最低路线是到B的路线，为50元。所以雇佣一个路人前往B,在那里他成为代理人。当他
         * 到达那里时，他通过电话告知，B的站长告诉他从B到C的费 用是60元，到D的费用是90元。
         *      经过简单计算即知，从A经过B到C的费用是50元加60元，即110元。所以修改笔记本上C的条目。同时可
         * 以看到，从A经过B到D必须花50元加90元，即140元。然而（这是关键部分）刚才已经知道从A直接到D只需要
         * 80元。由于只关心从A出发的最低费用路线，所以忽略这条较贵的路线，笔记本上的相应条目也不作修改。修
         * 改后的结果见下表：
         *          从A到         B           C           D            E
         *          step1       50(via A)    inf         80(via A)    inf
         *          step2       50(via A)*   110(via B)  80(via A)    inf
         *      在某个城市有代理人后，可以确定这个代理人走过的路线是费用最低的路线。为什么呢？考虑现在的情
         * 形。如果有另外一条线路比从A到B的直接连接更便宜，它需要通过其他的城市。但是从A出发的另一条路线是
         * 到达,它己经比到B的直接连接更贵了。加上从D到B的费用，使得这条路线更加昂贵。
         *      因此可以确定，从现在开始，不需要改动从A到B的最低贲用。不管找到什么城市，这个费用都不会改变。
         * 在它旁边标注一个*,表示在这个城市有一个代理人，并且到它的最低费用是固定的。
         *      三种城市
         *          和最小生成树算法一样，需要把城市分成三种类型：
         *              1.已经有代理人的城市：它们己在树中。
         *              2.从有代理人的城市出发已知到达所需费用的城市;它们是边缘城市。
         *              3.未知城市。
         *      现在，A和B是第一类的城市，因为它们那里己经有代理人。第一类城市形成了一棵树，它包含了所有从
         * 源点出发，到达各个目的顶点的路径。（显然，这和最小生成树不同)。
         *      还有一些城市没有代理人，但是已经知道了到它们那里的费用，因为在邻接的第一类城市中有代理人。
         * 比如现在知道从A到D的费用是80元，从B到C的费用是60元。因为这些费用是己知的，D和C是第二类（边缘）
         * 城市。
         *      现在还不知道关于E的情况，它是“未知”顶点。和最小生成树算法一样，随着算法的执行，城市从未知
         * 类型，变到边缘类型，最后进入树中。
         *  - 第三个代理人：在Danza
         *      现在，已经知道从A到没有代理人的任意城市的最低费用是80元，它是从A到D的直接线路。A-B-C——线
         * 需要 110 元，A-B-D——线需要140元，都比A-D贵。
         *      雇佣另外一个路人，把他派到D。他报吿从D花费20元可到C，70元可到E。现在可以修改笔记本上C的条
         * 目。之前，从A转道到C需要110元。而如果转道从D到C只需要100元。而且可以知道从A,通过D到以前未知的
         * 城市E的费用是150元。注意这些变化，如下表所示：
         *          从A到         B           C           D            E
         *          step1       50(via A)    inf         80(via A)    inf
         *          step2       50(via A)*   110(via B)  80(via A)    inf
         *          step3       50(via A)*   100(via D)  80(via A)*   150(via D)
         *  - 第四个代理人：在C
         *      现在到达没有代理人的任意城市的最低费用是100元，即从A穿过D到达C。因此，派一个代理人沿这条
         * 路径到达C。他报告从那到E需要40元。现在能够计算出，既然A到C (通过D)是100元，从C到E是40元，那么
         * 从A到E的最低费用可以从150元（A-D-E——线）降低到140元（A-D-C-E——线）。由此更新笔记本的内容，如
         * 下表：
         *          从A到         B           C           D            E
         *          step1       50(via A)    inf         80(via A)    inf
         *          step2       50(via A)*   110(via B)  80(via A)    inf
         *          step3       50(via A)*   100(via D)  80(via A)*   150(via D)
         *          step4       50(via A)*   100(via D)* 80(via A)*   140(via D)
         *  - 最后一个代理人：在E
         *      现在到达没有代理人的任意城市的最低费用是140元，即从A依次穿过D和C到达E。派一个代理人到E,但
         * 是，他报告说那里没有到达其他没有代理人的城市的线路。(有一 条到B的线路，但B己经有代理人了。）下表
         * 显示了笔记本的最后一行。所做的全部工作就是在E条目旁加星号，表示那里己经有代理人了。
         *          从A到         B           C           D            E
         *          step1       50(via A)    inf         80(via A)    inf
         *          step2       50(via A)*   110(via B)  80(via A)    inf
         *          step3       50(via A)*   100(via D)  80(via A)*   150(via D)
         *          step4       50(via A)*   100(via D)* 80(via A)*   140(via D)
         *          step5       50(via A)*   100(via D)* 80(via A)*   140(via D)*
         *      当每个城市都有代理人后，就知道了A到每个城市的费用。所以要求的工作就完成了。不再需要额外的计
         * 算，笔记本的最后一行显示了从A到其他所有城市的费用最低路线。
         *      这段描述说明了Dijkstra算法的本质。关键是
         *          •每次派一个代理人到新的城市，用这个代理人提供的新信息修正费用表单，在表中只保留从源点到
         *          某个城市现在已知的最低费用。
         *          •不断向某个新城市派代理人，条件是从源点到那个城市的路线费用最低（并不是从某个有代理人的
         *          城市出发的费用最低的路线，那是在最小生成树中用到的。）
         */
        path();
        /**
         * 每一对顶点之间的最短路径问题
         *      在第13章讨论连通性的时候，曾经想知道如果不介意中途的换乘，是否可以从Athens飞到 Murmansk。
         * 在带权图中，可以回答第二个问题，这个问题在Hubris航线柜台前等待时可能会产生：这趟旅行的花费是多少？
         *      为了看出某条路线是否可能，需要创建一个连通表。在带权图中，用一张表给出任意两个顶点间的最低耗
         * 费，这对顶点可能通过几条边相连。这种问题叫做每一对顶点之间的最短路径问题。
         *      依次用每个顶点做起始点，执行path.java程序，就可以得到这样一张表。如下表所示：
         *              A       B       C       D       E
         *         A    -       50      100     80      140
         *         B    -       -       60      90      100
         *         C    -       90      -       180     40
         *         D    -       110     20      -       60
         *         E    -       50      110     140     -
         *      在前面的章节中会发现，Warshall算法可以很快的创建这样的表，来显示从某个顶点通过一步或若干步到
         * 达其他顶点。带权图中类似的方法叫做Floyd算法，它是由Robert Floyd在1962年发明的。这是创建如上方所示
         * 的表格的另外一种方法。
         *
         *                      70                         A    B   C   D
         *                 A    ←    B                 A
         *              30 ↑         ↓ 10              B  70            10
         *                 C    ←    D                 C  30
         *                      20                     D            20
         *
         *      下面用一个简单的图来讨论Floyd算法。上图显示了一个有向带权图和它的邻接矩阵。
         *      邻接矩阵显示了所有单段路径的耗费。现在想扩展这个矩阵，显示所有路径的耗费，但不考虑它的长度。例
         * 如，从上图可以看出，从B到C的耗费是30 (从B到D是10，从D到C是20,和为30)。
         *      正如在Warshall算法中那样，可以系统的修改邻接矩阵。检査每行的每个单元。如果有非0的权值（例如C行
         * A列的30)，那么就看列C (因为C是30所在的行）。如果在C列找到一个非0权值（例如，D行的20),那么就可以知
         * 道从C到A有一条权值为30的路径，从D到C有一条权值为20的路径。由此可以断定从D到A有一条两条边组成的路径，
         * 权值为50。
         *      行A是空的，所以不需要做什么。在B行，A列处有70, D列处有10,但是B列是空的，所以B列的这些项不可能
         * 和以B为终点的边结合。然而，在C行，发现在A列有30。下面看C列，发现在D行有20。现在有从C到A的路径权值为
         * 30,从D到C的路径权值为20,所以，得到从D到A的路径权值为50。
         *                                A    B   C   D
         *                            A
         *                            B  70            10
         *                            C  30
         *                            D  50            20
         *      D行出现了一个有趣的情况：可以得到一个比已存在的权值更低的权值。在列A为50,在B行D列为10,所以知道
         * 从B到A的路径权值为60。然而，在这个单元已经有一个数字——70。那么 该怎么办？因为60小于70,所以用60取代70。
         * 在这种两点间多路径的情况下，要求这个表要保持有最小耗费的路径。
         *      Floyd算法的实现与Warshall算法类似。然而，在Warshall算法中当找到一个两段路径时，只是简单的在表中
         * 插入1，在Floyd算法中，需要把两端的权值相加，并插入它们的和。算法的细节在练习中给出。
         *
         * 效率
         *      迄今为止，还没有讨论各种图的算法的效率。由于图的表示法有两种，邻接矩阵和邻接表，使得这个问题变得相
         * 对复杂。
         *      如果使用邻接矩阵，前面讨论的算法大多需要O(V^2)的时间级，这里V是顶点的数量。为什么？ 如果分析这些
         * 算法，就发现它们几乎都检查了一遍所有顶点，具体方法是在邻接矩阵中扫描每一行， 依次査看每一条边。换句话讲，
         * 邻接矩阵的每个单元，一共有V^2个单元，都被扫描过。
         *      对于规模大的矩阵，O(v^2)的时间级不是非常好的性能。如果图是密集的，那就没有什么提高性能的余地。（正
         * 如前面看到的，密集意味着图有很多边，而它的邻接矩阵的许多或大部分单元被占。）
         *      然而，许多图是稀疏的，与稠密相反。其实并没有一个确定数量的定义说明多少条边的图是稠密的或是稀疏的，
         * 但是如果在一个大图中每个顶点只有很少几条边相连，那么这个图通常被认为是稀疏的。
         *      在稀疏图中，使用邻接表的表示方法代替邻接矩阵，可以改善运行时间。这很容易理解：不必浪费时间来检索邻
         * 接矩阵中没有边的单元。
         *      对于无权图，邻接表的深度优先搜索需要O(V+E)的时间级，这里V是顶点数量，E是边的数量。对于带权图，最小
         * 生成树算法和最短路径算法都霱要O((E+V)logV)的时间级，在大型的稀疏图中，与邻接矩阵方法的时间级相比，这样
         * 的时间级可使性能大幅提升。然而，算法多少会更加复杂一些，这就是为什么在本章中仍然使用邻接矩阵方法的原因。
         * 可以参考Scdgewick和其他作者用邻接表方法实现图的算法的例子。
         *      Warshall算法和Floyd算法比到目前为止本书讨论过的所有算法花费的时间都要长。它们的执行需要O(V^3)的时
         * 间级。这是因为在它们的实现中使用了三层嵌套的循环。
         *
         * 难题
         *      本书中，已经看到了大O的值，从(1),通过O(N)，O(N),O(N*logN),O(N^2)，一直到(Warshall算法和Floyd算法）
         * O(N^3)。甚至O(N^3)时间级的问题当N为几千时，也能在可接受的时间内完成。这些大O值的算法可以用来解决绝大多数
         * 实际问题。
         *      然而，有些算法的大O值非常大，以至于只有在N值非常小的时候才有解。许多真实世界需要用这种算法来解决的
         * 难题，简直不能在合理的时间内完成。这样的问题称作“难题”。（这样的问题有另外一个术语叫做NP完全性，NP的意思
         * 是"不确定多项式"(non-deterministic polynomial)。对这个定义的解释超出了本书的范围
         *
         * 骑士周游
         *      骑士周游（第13章的编程作业13.5)是一个难题的例子，因为可能的移动步数非常大。可能的移动序列的总数虽然
         * 很难计算，但是可以估计它。每次移动最多有八个选择。如果考虑移动后骑士出了棋盘或目标位置己经访问过，那么这个
         * 移动数宇会缩减。在周游初期，接近八种移动方向. 但是随着棋盘被填满，这个数字逐渐下降，假设（保守地）从每个位
         * 置只有两步可能的移动。除了初始化位置，骑士要访问63个方块，因此，共有2^63种可能的移动。这大约是10^19。如果
         * 一台计算机一秒钟可以计算一百万次移动（10^6)。一年大约是10^7秒，那么这台计算机一年可以计算10^13次移动。如
         * 此解决这个问题就需要10^6,也就是一百万年的时间。
         *      如果使用决策树剪枝的策略。这个特殊问题可以转化为可解的。其中有一种是Warnsdorff的启发式策略
         * （H.C.Von Warnsdorff, 1823）,他指出每次要移动到出路可能性最小的方块上去。
         *
         * 旅行商问题
         *      下面是另一个著名的难题：假定有一个商人，需要驾车到所有客户所在的城市，但是他希望走过的路线最短。商人
         * 知道从每个城市到另外的城市的距离。商人要从自己的城市出发，在每个客户城市访问一次且仅一次，然后回到自己的城
         * 市。以什么顺序访问这些城市可以使走过的路程最短？ 在图论中，这是旅行商问题，简称TSP（travelling salesman problem）。
         *      下图显示了一组城市和它们之间距离的图（数字代表两点之间有连线，并且是连线的权值）：
         *
         *                   A        91          B
         *                        62        44
         *                   55       C           31
         *                        52        45
         *                   D        83         E
         *
         *      从A出发，访问所有城市再冋到A,哪条路线是最短的？注意，每对城市不必都是直接相连。例如，由于地形的原因，
         * 他必须经过Philadelphia,就能从 Washington, D.C.到达 New York。
         *      为了找到最短距离，他列出所有可能的城市组合 (Boston-Sealtle-Miami, Boston-Miami-Seattle, Miami-
         * Boston-Seattle等等）,然后计算每种组合的总里程数。路线ABCEDA总长为318。路线ABCDEA不存在，因为没有从E直接
         * 到A的路线。
         *      不幸的是，组合的数量非常巨大：它是城市数量的阶乘（不计算出发城市）。如果有六个城市要访问，那么在出发
         * 城市就有六个城市可以选择，第二个有5个，第三个有4个，依次类推：一共有6*5*4*3*2*1，即720种可能的路线。这个
         * 问题的规模如果是50个城市，就是不切实际的。另外，有一些策略可以去掉那些不可能的序列，但是这样做帮助不大。用
         * 带权图来解决这个问题，权值代表英里数，顶点代表城市。如果像一般的理解那样，从A到B与从B到A的距离相同，那么这
         * 个图是无向图。如果权值代表的是飞机票价，那么不同方向可能就不同，就应该使用有向图来表示。
         *
         * 汉密尔顿回路
         *      这个问题与TSP相似，但是更加抽象，它要找到图的汉密尔顿回路。正如前面说到的，回路是一条源点和终点都是同
         * 一个顶点的路径。汉密尔顿回路中访问一次且只访问一次其他顶点。与TSP的区别是，这里不关心距离：惟一关心的是是否
         * 有这样的回路存在。在上图中，ABCEDA是一个汉密尔顿回路，而ABCDEA不是。骑士周游问题是汉密尔顿回路问题的一个实
         * 例（假设骑士每次回到他出发的方块）。
         *      找汉密尔顿回路与TSP一样，都需要O(N!)的时间级。通常用术语“指数级时间”表示大O值为2^n或N!(増长的速度比2N
         * 还要快）的时间级。
         */
         /**
         * 小结
         *  - 带权图中，边带有一个数字，叫做权，它可能代表距离、耗费、时间或其他意义。
         *  - 带权图的最小生成树中有所有的顶点和连接它们的必要的边，且这些边的权值最小。
         *  - 优先级队列的算法可用于寻找带权图的最小生成树。
         *  - 带权图的最小生成树模拟了真实世界的许多情况，例如在两城市间铺设线缆。
         *  - 无权图的最短路径问题要找到两点间的路径，且路径长度最短。
         *  - 带权图的最短路径问题产生的路径总权值和最小。
         *  - 带权图的最短路径问题可以用Dijkstra算法解决。
         *  - 对于大型的稀疏图，用邻接表表示，相对于用邻接矩阵表示，可以提高算法的运行效率。
         *  - 每一对顶点间的最短路径问题是要找到图中每对顶点间的权值和。Floyd算法用来解决这
         * 个问题。
         *  - 有些图的算法需要指数级时间，因此在顶点多的图中应用不太实际。
         */
    }

    public static void path() {
        GraphD theGraph = new GraphD();
        theGraph.addVertex('A');     // 0  (start)
        theGraph.addVertex('B');     // 1
        theGraph.addVertex('C');     // 2
        theGraph.addVertex('D');     // 3
        theGraph.addVertex('E');     // 4

        theGraph.addEdge(0, 1, 50);  // AB 50
        theGraph.addEdge(0, 3, 80);  // AD 80
        theGraph.addEdge(1, 2, 60);  // BC 60
        theGraph.addEdge(1, 3, 90);  // BD 90
        theGraph.addEdge(2, 4, 40);  // CE 40
        theGraph.addEdge(3, 2, 20);  // DC 20
        theGraph.addEdge(3, 4, 70);  // DE 70
        theGraph.addEdge(4, 1, 50);  // EB 50

        println("Shortest paths");
        theGraph.path();             // shortest paths
        println();
    }

    public static void mstw() {
        Graph theGraph = new Graph();
        theGraph.addVertex('A');    // 0  (start for mst)
        theGraph.addVertex('B');    // 1
        theGraph.addVertex('C');    // 2
        theGraph.addVertex('D');    // 3
        theGraph.addVertex('E');    // 4
        theGraph.addVertex('F');    // 5

        theGraph.addEdge(0, 1, 6);  // AB  6
        theGraph.addEdge(0, 3, 4);  // AD  4
        theGraph.addEdge(1, 2, 10); // BC 10
        theGraph.addEdge(1, 3, 7);  // BD  7
        theGraph.addEdge(1, 4, 7);  // BE  7
        theGraph.addEdge(2, 3, 8);  // CD  8
        theGraph.addEdge(2, 4, 5);  // CE  5
        theGraph.addEdge(2, 5, 6);  // CF  6
        theGraph.addEdge(3, 4, 12); // DE 12
        theGraph.addEdge(4, 5, 7);  // EF  7

        print("Minimum spanning tree: ");
        theGraph.mstw();            // minimum spanning tree
    }
}

