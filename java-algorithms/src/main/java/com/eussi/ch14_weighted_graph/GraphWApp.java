package com.eussi.ch14_weighted_graph;

import com.eussi.ch14_weighted_graph.util.Graph;
import com.eussi.util.Util;

/**
 * @author wangxueming
 * @create 2020-03-09 19:25
 * @description
 */
public class GraphWApp {
    /**
     * 带权图
     *      在前一章己经看到了图的边可以有方向。本章中，将要探讨边的另一个特性：权值。例如，
     * 如果带权图的顶点代表城市，边的权可能代表城市间的距离，或者城市间的飞行费用，或者两城
     * 市间每年的汽车流量（高速公路建设者往往对这个感兴趣）。
     *      当把权值当作边的特性时，一些有趣和复杂的问题也就出现了。什么是带权图的最小生成树？
     * 什么是两个顶点间的最短（或造价最低）距离？这些问题在现实世界中有重要的意义。
     *      首先来看有权的无向图以及它的最小生成树。在本章后半部分，将讨论带有方向和权值的图，
     * 同时探讨著名的Dijkstra算法，并利用它寻找两点间的最短路径。
     */

    public static void main(String[] args) {
        /**
         * 带权图的最小生成树
         *      要引入带权图，首先回到最小生成树的问题。在有向图中创建这样一棵树比在无向图中
         * 要复杂一点。当所有的边拥有相同的权值，问题变得简单了（正如第13章中看到的），算法可
         * 以任意选择一条边加入最小生成树。但是当边具有不同的权值时，需要用一些算法策略来选择
         * 正确的边。
         *
         * 一个实例：丛林中的有线电视
         *      假设要在一个虚拟的国家Magnaguena的6个城市之间架有线电视网，把它们都连接起来。
         * 五条边可以连接六个点，但是应该是哪五条边呢？连接每两个城市的造价不同，所以必须仔细
         * 选择线路使得总体造价最低。
         *
         *                        B  ——  C             六个顶点两两相连，线的方向代表连接点，线上数字代表权重
         *                   6/   7\   8/   \6
         *                A     7|   \  5|    F
         *                   4\     /  \   /7
         *                        D  ——  E
         *                           12
         *
         *      上图显示了一个有6个顶点的带权图，代表6个城市，A、B、C、D、E和F。每条边有一个
         * 权值，标记在边的旁边。假设这些数字代表在两城市间架设电缆的造价，1 代表一百万元。
         * （注意，由于地形原因会导致距离太远，所以一些边是不必要的；例如，假设从A到C或从D到F
         * 距离太远， 所以这些边不予考虑，也没有出现在图中。）
         *      选择哪些边架设电缆，能使得安装有线电视系统的造价最低呢？答案是利用最小生成树。
         * 它将有五条边（比城市的数量少1)，连接六个城市，并具有建立连接所需的最小代价。通过看
         * 上图，能否直接找出这些边呢？
         *      通过算法可以看出如下最小生成树：
         *                        B       C
         *                   6/   7\        \6
         *                A          \  5|    F
         *                   4\        \
         *                       D       E
         * 派遣调查员
         *      构造最小生成树的算法有些棘手，为了介绍这个算法先引入一个有线电视雇员的例子。现
         * 在有一个雇员（当然是经理）和一些调查员。
         *      计算机算法（除非它可能是神经网络）不能一次“知道”给定问题的所有数据：它不能处理
         * 全面的大图，只能一点一点地得到数据，随着处理过程的深入，不断修改问题的结果。对于图来
         * 说，算法从某个顶点开始工作，首先得到这个点附近的数据，然后找到更远顶点的数据。在前面
         * 一章，深度优先捜索和广度优先搜索就是同样的例子。
         *      同样，假设开始不知道任意两个城市安装电缆需要多少钱。得到这些数据需要时间。这时
         * 就需要调査员。
         *  - 从A开始
         *      现在从在A建立办事处开始（可以在任意一个城市开始，但是A有最好的餐馆）。从只能到
         * 两个城市：B和D(参考上图）。雇佣两个强壮且熟悉丛林环境的调查员，把他们派到危险的荒野
         * 中去，一个前往B, 一个前往D。这个工作是为了确定在这两条路线上安装有线电视的造价。
         *      第一个调査员到达了 B,完成了他的调査，他通知总部说在A和B之间安装电缆要六百万。
         * 第二个调查员遇到了鳄鱼，晚些时候从D报告，A到D的电缆穿过更多的村庄，却只要四百万。现
         * 在得到一个表单：
         *      A-D, $4,000,000
         *      A-B, $6,000,000
         *      然后按价值大小抹序：很快将会看到为什么这是一个好方法。
         *  - 建立A-D的连接
         *      这时，可以正式派出建筑队安装从A到D的电缆。如何确定A-D一线最终是造价是最低方案
         * （最小生成树）的一部分？因为迄今为止，只知道整个系统的两条连线。难道不需要其他的信息
         * 了吗？
         *      为了对这个情况有一个直观感受.试想有其他的连接比当前从A到D的连接更省钱。如果它
         * 不是直接连接D,那么它必定是绕过B,然后 迂回到D,可能会穿过一个或更多的城市。但是现在己
         * 经知道到B的连接需要六百万，比到D的连接（4百万）更加昂贵。所以假设有其余可想像的路线
         * 更廉价，但是因为穿过了B而导致那些路线的造价比与D直接连接还要高，并且经过B到达环线上
         * 的其他城市比从D经过要昂贵。
         *      所以结论就是A-D是最小生成树的一部分。这里虽没有进行形式化的证明（证明超出本书
         * 范围），但是它确实表明选择目前造价最低的路线是最好的作法。所以应该安装从A到D的电缆，
         * 并在D建办事处。
         *      为什么需要办事处？这是该国政府的要求，在从一个城市派出调査员到邻近的城市前，必
         * 须在这个城市建办事处。用图的术语说，在得到某个顶点与之相连的边的权值前，必须把顶点加
         * 入到树中。有办事处的城市都用电缆彼此连接，没有办事处的城市都还没有连接。
         *  - 建立A-B的连接
         *      现在己经完成了 A-D的连接，并且在D修建了办事处，可以从D派出调查员去能够到达的城
         * 市，分别是B、C和E。调査员到达各自的终点.并报告三条连接的造价，分别为7百万、8百万和
         * 1千2百万。（当然，不需要派调査员去A,因为己经调查了它们之间的路线，并安装了电缆现在已
         * 经知道了从有办事处的城市到没有办是处的城市的4条路线，分别是:
         *      A-B, $6,000,000
         *      D-B, $7,000,000
         *      D-C, $8,000,000
         *      D-E, $12,000,000
         *      为什么A-D这条线路不在表单中？因为那里己经安装了电缆；没有必要对它作进一步的考虑，
         * 所以己经安装的路线一律从表单中删除。
         *      现在，接着做什么不是很明显。有许多潜在的路线可供选择。哪一条是最佳选择呢？下面是
         * 规则：
         *      “在表单中，总是选择造价最低的边”
         *      实际上，刚才在选择从A出发的线路时，已经使用了这个规则：A-D是造价最低的。这时，造
         * 价最低的边是A-B，所以花费6百万安装从A到B的电缆，并在B建办事处。
         *      在这里暂停一下，做个小结。在某个特定时间，电缆系统构造过程中，有三类城市：
         *       - 己经有办事处，并且用电缆连接的城市。（在图中，它们是最小生成树的顶点。）
         *       - 还没有连接，也没有办事处的城市，但是己知把它们连接到至少一个已有办事处的城市
         *       电缆的安装造价。这些城市叫做“边缘”城市。
         *       - 还不知道任何信息的城市。
         *      这样的话，A，D和B属于第一类，C和E属于第二类，而F属于第三类。随着算法的不断进行，
         * 城市从第三类变成第二类，再变成第一类。
         *  - 建立B-E的连接
         *      目前，A、D和B已接入电缆系统，也有了办事处。现在己经知道从A和D到第二类城市的造价，
         * 而不知道从B到第二类城市的造价，所以需要从B派遣调查员到C和E。他们报告说连接C需要1千万，
         * 连接E需要7百万。下面是新的表单：
         *      B-E, $7,000,000
         *      D-C, $8,000,000
         *      B-C, $10,000,000
         *      D-E, $12,000,000
         *      注意，D-B的连接原来在表单中，现在却没有了，因为没有必要考虑己连接的城市之间的连
         * 接问趣，即使它们不是直接相连的。
         *      从这个表单中可以看到，造价最低的路线是B-E,需要7百万，所以修建了这段电缆，并在E
         * 建立办事处。
         *  - 建立E-C的连接
         *      从E, 调查员报告连接C需要5百万，连接F需要7百万。D-E的连接必须从表单中删除，因为E
         * 现在是一个己连接的城市。新的表单是
         *      E-C, $5,000,000
         *      E-F, $7,000,000
         *      D-C, $8,000,000
         *      B-C, 10,000,000
         *      造价最低的连接是E-C,所以修建这条连接，并在C建立办事处。
         *  - 最后建立C-F的连接
         *      选择的范围现在变窄了，除去所有己经连接的城市，表单上只有两项：
         *      C-F, $6,000,000
         *      E-F, $7,000,000
         *      安装从C到F的电缆，在F建立办事处后，所有工作就完成了。由于每个城市都有了办事处，
         * 所以工作肯定完成了。建立的电缆路线是A-D、A-B、B-E、E-C和C-F，如上图最小生成树，这是
         * 连接六个城市造价最低的方案。
         *
         * 设计算法
         *      这个想像中安装有线电视系统的例子，己经阐释了寻找带权图最小生成树算法的主要思想。
         * 现在看一下如何根据这个过程设计算法。
         *
         * 优先级队列
         *      正如前面例子描述的那样，执行算法的关键行为是保存两城市间建立连接的造价表。通过
         * 选择造价最低的项，就可以决定下一条连接建在何处。
         *      建议用优先级队列来实现这个用于反复选择最小造价值的表，而不用链表或数组。这是解
         * 决最小生成树的有效方式。在正式的程序中，优先级队列可能基于堆来实现，正如第12章“堆’’
         * 所描述的。这会加快在较大的优先级队列中的操作。然而，在实例程序中，将用数组实现优先级
         * 队列。
         *
         * 算法要点
         *      下面用图的术语（相对于有线电视的术语）重申一下算法：
         *      从一个顶点开始，把它放入树的集合中。然后重复做下面的事情：
         *          1.找到从最新的顶点到其他顶点的所有边，这些顶点不能在树的集合中。把这些边放
         *          入优先级队列。
         *          2.找出权值最小的边，把它和它所到达的顶点放入树的集合中。
         *      重复这些步骤，直到所有顶点都在树的集合中。这时，工作完成。
         *      在步骤1, “最新的”意味着最近放入树中的。此步骤的边可以在邻接矩阵中找到。步骤1完
         * 成后，表中包含了所有的边，这些边都是从树中顶点到它们的不在树中的邻接点（边缘点）的连接，
         *
         * 无用边
         *      在表剩余条目中，想要把某些连接删除比较困难，它们都是从当前城市到已经拥有办事处的城
         * 市的连接。但是如果不做这个工作，就可能会导致安装不必要的有线电缆。
         *      在程序的算法中，也要确保优先级队列中不能有连接己在树中的顶点的边。每次向树中增加顶
         * 点后，都要遍历优先级队列査找并删除这样的边。这样做了以后，要使优先级队列中在任意时刻只保
         * 持一条从树中顶点到某边缘点的边就变得容易了。也就是说，优先级队列中应该只包含一条到达某个
         * 第二类顶点的边。
         *
         * 步骤表
         *      下表显示了步骤：
         *      步骤  没剪除的边列表     减除边列表(在优先级队列中)  优先级队列中因重复删掉的边
         *      1     AB6,AD4           AB6,AD4
         *      2     DE12,DC8,DB7,AB6  DE12,DE8,AB6             DB7(AB6)
         *      3     DE12,BC10,DC8,BE7 DC8,BE7                  DE12(BE7),BC10(DC8)
         *      4     BC10,DC8,EF7,EC5  EF7,EC5                  BC10(EC5),DC8(EC5)
         *      5     EF7,CF6           CF6                      EF7
         *      记住，一条边包含源（起始）点的字母，汇（结束）点的字母和权值。表中的第二列对应构造
         * 有线电视系统时的表。它显示了从第一类顶点（已在树中的顶点）到第二类顶点（至少有一条边与第
         * 一类顶点相连）的边。
         *      第三列是运行算法时，优先级队列的变化情况。任何与其他边有相同终点的边，如果权值较大，
         * 就从队列中刪除。
         *      第四列显示了已经被删除的边，括号中是权值较小的边，它取代了权值较大的边，保留在队列中。
         * 记住，在步进执行的过程中，表中最后一项肯定要被删除，因为它己经加到树中。
         *
         * 在优先级队列中寻找目的地重复的边
         *      如何保证以每个第二类顶点为目的地的边只有一条？每次向树中增加边的时候，一定要确保没
         * 有其他边也到达同样的顶点。如果有，只保留最小权值的边。
         *      这使得在优先级队列中逐项査找成为必要的一步操作。査找的目的是看是否有这样的重复边。
         * 优先级队列设计初衷本不为随机访问的，所以这不是一个有效的方法。然而，在这种情况下，必须违
         * 反一下优先级队列的设计思想。
         */
        mstw(); // minimum spanning tree weighted
        Util.printSeparator();
    }

    public static void mstw()
    {
        Graph theGraph = new Graph();
        theGraph.addVertex('A');    // 0  (start for mst)
        theGraph.addVertex('B');    // 1
        theGraph.addVertex('C');    // 2
        theGraph.addVertex('D');    // 3
        theGraph.addVertex('E');    // 4
        theGraph.addVertex('F');    // 5

        theGraph.addEdge(0, 1, 6);  // AB  6
        theGraph.addEdge(0, 3, 4);  // AD  4
        theGraph.addEdge(1, 2, 10); // BC 10
        theGraph.addEdge(1, 3, 7);  // BD  7
        theGraph.addEdge(1, 4, 7);  // BE  7
        theGraph.addEdge(2, 3, 8);  // CD  8
        theGraph.addEdge(2, 4, 5);  // CE  5
        theGraph.addEdge(2, 5, 6);  // CF  6
        theGraph.addEdge(3, 4, 12); // DE 12
        theGraph.addEdge(4, 5, 7);  // EF  7

        System.out.print("Minimum spanning tree: ");
        theGraph.mstw();            // minimum spanning tree
        System.out.println();
    }  //
}

