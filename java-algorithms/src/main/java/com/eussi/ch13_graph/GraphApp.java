package com.eussi.ch13_graph;

import com.eussi.ch13_graph.util.Graph;
import com.eussi.util.Util;

/**
 * @author wangxueming
 * @create 2020-03-04 19:01
 * @description
 */
public class GraphApp {
    /**
     * 图
     *      在计算机程序设计中,图是最常用的结构之一。一般来说,用图来帮助解决的问题类型与
     * 本书中已经讨论过的问题类型有很大差别。如果处理一般的数据存储问题,可能用不到图,但对
     * 某些问题(经常是一些有趣的问题),图是必不可少的。
     *      对图的讨论分成两章。本章讨论不带权的图,展示这些图的算法。下一章讨论关于带权图
     * 的更复杂的算法。
     */
    public static void main(String[] args) {
        /**
         * 图简介
         *      图是一种与树有些相像的数据结构。实际上,从数学意义上说,树是图的一种。然而,在计算
         * 机程序设计中,图的应用方式与树不同。
         *      本书前面讨论的数据结构都有一个框架,这个框架都是由相应的算法规定的。例如,二叉树是
         * 那样一个形状,就是因为那样的形状使它容易搜索数据和插入新数据。树的边表示了从一个节点到
         * 另一个节点的快捷方式。
         *      另一方面,图通常有一个固定的形状,这是由物理或抽象的问题所决定的。例如,图中节点表
         * 示城市,而边可能表示城市间的班机航线。另一个更抽象的例子是一个代表了几个单独任务的图,
         * 这些任务是完成一个项目所必需的。在图中,节点可能代表任务,有向边(在一端带一个箭头)指
         * 示某个任务必须在另一个任务前完成。在这种情形下,图的形状取决于真实世界的具体情况。
         *      在继续讨论下去之前,必须说明,当讨论图时,节点通常叫做顶点。可能是因为图的命名在几
         * 个世纪前的数学领域就有了,所以它比树的命名要早。树和计算机科学联系得更紧密一些。但是,
         * 这些术语或多或少会交替使用
         *
         * 定义
         *      下图是模拟美国加利福尼亚 San Jose周边地区的简化的高速公路网的图。
         *      在图中,字母代表高速公路的交汇点,连接圆圈的直线代表高速公路段。字母是顶点,线是边。
         * 顶点通常用一些方法来标识——正如图中显示的那样,用字母表中的字母来表示。每条边由两个顶
         * 点作为两端。
         *      图并不是要试图反映地图上的地理位置;它只是显示了顶点和边的关系——即,哪些边连接着
         * 哪些顶点。它本身不涉及物理的远近和方向。而且一条边可能代表几条不同的公路,例如从I到H
         * 的情形中,就包含了101号公路、84号公路和280号公路。两个交叉点间的连通性(或不连通性)
         * 是重要的,而实际的路线并不重要。
         *
         *         I——————————————————J
         *         |\                / \
         *        |  \             /    \
         *        |   G————F——————E—————D
         *       |    /     \    /    /
         *       |  /          A     /
         *       | /         |  \   /
         *       H——————————B—————C
         *
         * 邻接
         *      如果两个顶点被同一条边连接,就称这两个顶点是邻接的。上图中,顶点I和G是邻接的
         * 但I和F就不是。和某个指定顶点邻接的顶点有时叫做它的邻居。例如G的邻居是I、H和F
         *
         * 路径
         *      路径是边的序列。上图显示了一条从顶点B到顶点J的路径,这条路径通过了顶点A和顶
         * 点E。这条路径称作BAEJ。这两个顶点之间还有其他路径:从B到J的另一条路径是BCDJ。
         *
         * 连通图
         *      如果至少有一条路径可以连接起所有的顶点,那么这个图被称作连通的,例如上图。然而,
         * 如果“不能从这里到那里”,那么这个图就是非连通的。
         *      非连通图包含几个连通子图。简便起见,本章讨论的算法都是应用在连通图或非连通图的
         * 连通子图中。如果需要,进行一些小的修正就可以使它们应用在非连通图中。
         *
         * 有向图和带权图
         *      上图图是无向图。这说明图中的边没有方向;可以从任意一边到另一边。所以,可以从顶点A到顶
         * 点B,也可以从顶点B到顶点A,两者是等价的。(无向图很好地模拟了高速公路网,因为在一条公路上可
         * 以按两个方向行驶。）
         *      然而,图还经常用来模拟另一种情况,即只能沿着边朝一个方向移动——只能从A到B,而不
         * 能从B到A,就像单行道一样。这样的图被称作是有向的。允许移动的方向在图中通常用边一端的
         * 箭头表示。
         *      在某些图中,边被赋予一个权值,权值是一个数字,它能代表两个顶点间的物理距离,或者从
         * 个顶点到另一个顶点的时间,或者是两点间的花费(例如飞机航线)。这样的图叫做带权图。下
         * 章将讨论它们。
         *      本章开始我们将讨论简单的无向、无权图,后面将探讨有向无权图
         *      我们无法覆盖所有应用于图的定义,但我们会尽可能多介绍一些
         *
         * 历史的笔记
         *      研究图最早的数学家之一是18世纪的欧拉( Leonhard euler)。他解决了一个著名的难题,关于
         * 波兰 Konigsberg镇的桥的问题。这个镇有一个小岛和七座桥，简化如下图：
         *                                   ————C
         *                                 /   /   \
         *                           c  /     /      \ g
         *                          /      /d          \
         *                      /       /                \
         *                    A  ———————————————————————— D
         *                    | \          e             /
         *                     \  \                    /
         *                       \   \               /
         *                       a \   \ b         / f
         *                           \   \       /
         *                             \   \   /
         *                              ————B
         *
         *      这个问题已经被市民讨论很多次了,它要寻找到一条走遍所有桥的路线,但不允许包含任何交
         * 叉路线。在这里不打算叙述 Euler的解决方案,它的结果是没有这样一条通路。然而,解决问题的
         * 关键所在是把这个问题用图表示,其中把岛的区域作为顶点,桥作为边,如上图所示。这可能是把图用
         * 于表示真实世界的一个具体问题的第一个例子。
         *
         * 在程序中表示图
         *      计算机发明以前,以抽象的方式考虑图是非常恰当的,就像 Euler和其他数学家做的那样,但
         * 是现在需要用计算机来描述图。什么样的软件结构适合于模拟图?首先来看顶点的情况,然后是边
         * 的情况。
         *  - 顶点
         *      在非常抽象的图的问题中,只是简单地把顶点编号,从0到N-1(这里N是顶点数)。不需要
         * 任何变量类型存储顶点,因为它们的用处来自于它们之间的相互关系。
         *      然而在大多数情况下,顶点表示某个真实世界的对象,这个对象必须用数据项来描述。例如,
         * 如果在一个飞机航线模拟程序中,顶点代表城市,那么它需要存储城市名字、海拔高度、地理位置
         * 和其他相关信息。因此,通常用一个顶点类的对象来表示一个顶点。示例程序仅存储了一个字母(例
         * 如A),用来标识顶点,同时还有一个标志位,后面将会看到它在搜索算法中的作用。
         *      顶点对象能放在数组中,然后用下标指示。在本例中,用数组 vertexList存储顶点对象。顶点
         * 也可以放在链表或其他数据结构中。不论使用什么结构,存储只为了使用方便。这与边如何连接点
         * 没有关系。要达到这个目的,还需要其他机制。
         *  - 边
         *      在第9章“红黑树”中,可以看到计算机程序能用几种方式表示树。大多数情况下讨论的树都
         * 是每个节点包含它的子节点的引用,但也提到过用数组表示树,数组中的节点位置决定了它和其他
         * 节点的关系。在第12章“堆”中,就用数组表示了一种树的类型,叫做“堆”。
         *      然而,图并不像树,拥有几种固定的结构。二叉树中,每个节点最多有两个子节点,但图的每
         * 个顶点可以与任意多个顶点连接。例如,上图中,顶点A与三个顶点连接,而C只与一个顶点
         * 连接。
         *      为了模拟这种自由形式的组织结构,需要用一种不同的方法表示边,比树的表示方法更合适些。
         * 一般用两个方法表示图:即邻接矩阵和邻接表。(记住,如果一条边连接两个顶点,这两个顶点就
         * 是邻接的。)
         *  - 邻接矩阵
         *      邻接矩阵是一个二维数组,数据项表示两点间是否存在边。如果图有N个顶点,邻接矩阵就是
         * N*N的数组。下表显示了上图中图的邻接矩阵
         *               A            B            C             D
         *        A      0            1            1             1
         *        B      1            0            0             1
         *        C      1            0            0             0
         *        D      1            1            0             0
         *
         *      顶点被用作行和列的标题。两个顶点间有边则标识为1,没有边则标识为0(也可以使用布尔
         * 变量的true/false值来标识)。如表所示,顶点A和另外三个顶点邻接,B和A、D邻接,C只与A
         * 邻接,而D与A和B邻接。在本例中,顶点与其自身的“连接”设为0,从A-A到D-D称为主(同一）
         * 对角线,所以这条从左上角到右下角的对角线全部是0。主对角线上的实体不代表任何真实世
         * 界的信息,所以为了方便,也可以把主对角线的值设为1
         *      注意,这个矩阵的上三角是下三角的镜像:两个三角包含了同样的信息。这个冗余信息看似低
         * 效,但在大多数计算机语言中,创造一个三角形数组比较困难,所以只好求其次接受这个冗余。这
         * 也要求当增加一条边时,必须更新邻接矩阵的两部分,而不是一部分
         *
         *  - 邻接表
         *      表示边的另一种方法是邻接表。邻接表中的表指的是第5章“链表”中讨论的那种链表。实际
         * 上,邻接表是一个链表数组(或者是链表的链表)。每个单独的链表表示了有哪些顶点与当前顶点
         * 邻接。下表显示了上图中图的邻接表。
         *              顶点                        包含邻接顶点的链表
         *              A                           B->C->D
         *              B                           A->D
         *              C                           A
         *              D                           A->B
         *
         *      在这个表中,符号->表示链表中的一个节点。链表中每个节点都是一个顶点。在这里的每个
         * 链表中,顶点按字母顺序排列,不过这并不是必需的。不要把邻接表的内容与路径混淆。邻接表表
         * 示了当前顶点与哪些顶点连接——即两个顶点间存在边,而不是表示顶点间的路径。
         *      后面会看到什么时候使用邻接矩阵,而什么时候使用邻接表。
         *
         * 在图中添加顶点和边
         *      为了向图中添加顶点,必须用new保留字生成一个新的顶点对象,然后插入到顶点数组
         * vertexList中。在模拟真实世界的程序中,顶点可能包含许多数据项,但是为了简便,这里假定
         * 顶点只包含单一的字符。因此顶点的创建用下面的代码
         *          vertexList[nVerts++] = new Vertex('F')
         *      这就插入了顶点F, nverts变量是图中当前顶点数
         *      怎样添加边取决于用邻接矩阵还是用邻接表表示图。假定使用邻接矩阵并考虑在顶点1和顶点
         * 3之间加一条边。这些数字对应vertexList数组的下标,顶点存储在数组的对应位置。首次创建邻接
         * 矩阵 adjMat时,初值为0。添加边的代码如下
         *          adjMat[1][3] = 1;
         *          adjMat[3][1] = 1;
         *      如果使用邻接表,就把1加到3的链表中,然后把3加到1的链表中。
         *
         *      邻接矩阵(或者邻接表)提供了关于当前顶点的位置信息。特别是,当前顶点通过边与哪些顶
         * 点相连。为了回答关于顶点序列的更一般问题,就必须求助于其他的算法。下面从搜索开始
         *
         * 搜索
         *      在图中实现的最基本的操作之一就是搜索从一个指定顶点可以到达哪些顶点。例如,可以想像
         * 要找出美国有多少个城市可以从 Kansas城乘坐旅行列车到达(假定中途不换车)。一些城市可以直
         * 达,而有些城市因为没有旅行列车服务而不能直达。有些地方即使有列车服务也不能到达,因为他
         * 们的铁轨系统(例如 Hayfork-Hicks ville RR用窄铁轨标准)不能和出发地或者沿途的标准铁轨系统
         * 相连
         *      还有另外一种情形可能需要找到所有当前顶点可到达的顶点。设想需要设计一个印刷电路板
         * 就像在计算机中使用的这一个。(打开机箱,看看它!)不同的部分[大多数是集成电路块(IC)]放
         * 置在电路板上,集成电路的针脚插在电路板的预留孔中。IC芯片焊接在恰当位置,它们的针脚通过
         * 连线( trace)与其他针脚保持电路连接。连线是在电路板表面的细小金属线。
         *      在图中,顶点代表每个针脚,边代表每条连线。在电路板上,有许多线路是互不相连的,所以
         * 图绝不是连通图。因此,设计过程中,创建一个图,利用它找到哪些针脚连接到同一电路中,真是
         * 太有用了。
         *      假设巳经创建了这么一个图。现在需要一种算法来提供系统的方法,从某个特定顶点开始,沿
         * 首边移动到其他顶点。移动完毕后,要保证访问了和起始点相连的每一个顶点。正如在第8章“二
         * 叉树”中讨论的二叉树一样,访问意味着在顶点上的某种操作,例如显示操作。
         *      有两种常用的方法可用来搜索图:即深度优先搜索(DFS)和广度优先搜索(BFS)它们最终
         * 都会到达所有连通的顶点。深度优先搜索通过栈来实现,而广度优先搜索通过队列实现。正如我们
         * 即将看到的那样,不同的机制导致了搜索的不同方式。
         *
         * 深度优先搜索
         *      在搜索到尽头的时候,深度优先搜索用栈记住下一步的走向。这里展示了一个例子,最好实验
         * 一下,最后考察一下执行搜索的具体代码。
         * 一个示例
         *      下面下图所示讨论深度优先搜索思想。图中的数字显示了顶点被访问的顺序。
         *              (2)    (3)    (4)
         *           /   B ———— F ————H
         *          /
         *         /  /  C(5)
         *          /
         *      A(1)
         *          \   (6)    (7)    (8)
         *        \  \   D ———— G ———— I
         *         \
         *          \    E
         *              (9)
         *
         *      为了实现深度优先搜索,找一个起始点——本例为顶点A。需要做三件事:首先访问该顶点,然后
         * 把该点放入栈中,以便记住它,最后标记该点,这样就不会再访问它。
         *      下面可以访问任何与顶点A相连的顶点,只要还没有访问过它。假设顶点按字母顺序访问,所以
         * 下面访问顶点B，然后标记它,并放入栈中。
         *      现在已经访问了B,做相同的事情:找下一个未访问的顶点,也就是F。这个过程称作规则1
         *          规则1：
         *              如果可能,访问一个邻接的未访问顶点,标记它,并把它放入栈中。
         *      再次应用规则1,这次访问顶点H。然而,这里还需要做一些事情,因为没有和H邻接的未访
         * 问顶点。下面是规则2。
         *          规则2
         *              当不能执行规则1时,如果栈不空,就从栈中弹出一个顶点
         *      根据这条规则,从栈中弹出H,这样就又回到了顶点F。F也没有与之邻接且未访问的顶点了。
         * 那么再弹出F,这回到顶点B。这时只有顶点A在栈中。
         *      然而A还有未访问的邻接点,所以访问下一个顶点C。但是C又是这一条路线的终点,所以从
         * 栈中弹出它,再次回到A点。接着访问D、G和Ⅰ。当到达I时,把它们都弹出栈。现在回到A,
         * 然后访问E,最后再次回到A。
         *      然而这次A也没有未访问的邻接点,所以把它也弹出栈。现在栈中已无顶点。下面是规则3。
         *          规则3
         *              如果不能执行规则1和规则2,就完成了整个搜索过程。
         *
         *      深度优先搜索算法要得到距离起始点最远的顶点,然后在不能继续前进的时候返回。使用深度
         * 这个术语表示与起始点的距离,便可以理解“深度优先搜索”的意义
         *
         * 模拟问题
         *      深度优先搜索与迷宫问题类似。迷宫在英国很流行,可以由一方给另一方设置障碍,由另一方
         * 想办法通过。迷宫由狭窄的过道(认为是边)和过道的交汇点(顶点)组成。
         *      假设有个人在迷宫中迷路。她知道有一个出口,并且计划系统地搜索迷宫找到出口。幸运的是
         * 她有一团线和一支笔。她从某个交汇点开始,任意选择一个通路,从线团上退下一些线。在下一个
         * 交汇点,她继续随机选择一条通路,再退下一些线,直到最后她到达死胡同。
         *      到达死胡同时,她按原路返回,把线再绕上,直到到达前一个交汇点。她标记了以前走过的路
         * 径,所以不会重复走那些通路,而选择未走过的通路。当她标记了这个交汇点的所有通路,就会再
         * 回到上一个交汇点,并且重复这个过程
         *      线代表栈:它“记住”了走向某个特定点的路径
         */
        dfs();
        Util.printSeparator();
        /**
         * 深度优先搜索和游戏仿真
         *      深度优先搜索通常用在游戏仿真中(以及真实世界中与游戏相似的情况)。在一般的游戏中
         * 可以在几个可能的动作中选择一个。每个选择导致更进一步的选择,这些选择又产生了更多的选择
         * 这样就形成了一个代表可能性的不断伸展的树形图。一个选择点代表一个顶点,采取的特定选择代
         * 表边,由它可以到达下一个选择顶点。
         *      想像一个名为tic-tac-toe的游戏。如果你先走,可以在九种可能的移动中选择一种。而对手只
         * 能在八种可能的移动中选择一种,依此类推。每次移动都导致了对手可以对当时的情况做出选择,
         * 而她的选择乂影响到你下一步的走向,直到最后一个方块被填充。
         *      当考虑如何走时,一种方法是在心中默想一步移动,然后对手可能的对策,然后是自己的对策,一
         * 直进行下去。可以通过考察哪一步移动能产生最好的结果来选择下一步怎么走。在 tic-tac-toe这
         * 种简单游戏中,可能的移动选择很有限,所以可以很轻松地沿每种路径考虑到游戏的最后一步。当
         * 分析了全部的路径后,就可以知道哪条路径最佳。这可以通过图来表示。图中的一个顶点代表首次
         * 移动,它连接着八个顶点,代表对手的八种移动可能,它们每一个又连接着七个顶点,代表相应的
         * 移动可能性,依此类推。从起始点到终点的所有路径都包含九个顶点。要做一个完整的分析,就需
         * 要画九张图,每张图代表不同的起始点。
         *      即使在这种简单的游戏中,搜索路径的数量也是出奇的大。如果可根据忽略所作的简化,九张
         * 图就会有9*8*7*6*5*4*3*2*1条路径。这是9的阶乘(9!),或362880。在国际象棋这种游戏中
         * 可能的移动数量还要大得多,因此,即使最强大的计算机(例如IBM的“深藍”)也不能“看到”
         * 比赛的结果。它们只能沿某条路径到达一定的深度,然后估算棋盘上的形式,来判断是否这个选择
         * 比其他的选择要好。
         *      用计算机考察这种问题,通常的方法是使用深度优先搜索。在每个顶点决定下一步的移动,就
         * 像 dfs.java程序中 getAdjUnvisitedVertex方法执行的那样。如果还有未访问的顶点(选
         * 择点),就把当前顶点入栈,然后继续选择。如果发现在某一点已经不能再作出选择
         * ( getAdjUnvisitedVertex()返回-1),就从栈中弹出一个顶点,并回到这个顶点处,然后看这里是否
         * 还有未试过的选择。
         *      可以把游戏中移动的序列考虑成一棵树,节点代表移动。首次移动是根节点。在tic- tac-toe游
         * 戏中,首次移动后只有八种可能的移动,那么有八个第二层节点与根节点连接。接下来只有七种可
         * 能的移动,那么每个第二层节点就有七个第三层节点与之相连。从根节点到叶节点,为构造这棵树
         * 需要有9!条路径。这叫作决策树。
         *      实际上,决策树中的每一支的数量可以缩减,因为在所有方格填满前,游戏可能已经结束了
         * 然而, tic-tac-toe游戏的决策树还是非常庞大和复杂,不过和国际象棋等游戏比起来,它还算是比较
         * 简单的游戏
         *      决策树中只有几条路径有成功解。例如,有些会导致对手获胜。当到达叶节点时,必须回复到,
         * 或者说回溯到上一个节点,尝试另一条路径。用这样的方法探索整棵树,直到找到获得成功解的路
         * 径。那么就可以根据这条路径作出第一步选择
         */

        /**
         * 广度优先搜索
         *      正如深度优先搜索中看到的,算法表现得好像要尽快地远离起始点似的。相反,在广度优先搜
         * 索中,算法好像要尽可能地靠近起始点。它首先访问起始顶点的所有邻接点,然后再访问较远的区域。这
         * 种搜索不能用栈,而要用队列来实现。
         *
         * 一个例子
         *      下图与上一个图相同,但是这里应用广度优先搜索策略。号码依旧表明访问顶点的顺序。
         *              (2)    (6)    (8)
         *           /   B ———— F ————H
         *          /
         *         /  /  C(3)
         *          /
         *      A(1)
         *          \   (4)    (7)    (9)
         *        \  \   D ———— G ———— I
         *         \
         *          \    E
         *              (5)
         *
         *      A是起始点,所以访问它,并标记为当前顶点。然后应用下面几条规则:
         *          规则1
         *              访问下一个未来访问的邻接点(如果存在),这个顶点必须是当前顶点的邻接点,标记它,并
         *          把它插入到队列中
         *          规则2
         *              如果因为已经没有未访问顶点而不能执行规则1,那么从队列头取一个顶点(如果存在),并使
         *          其成为当前顶点
         *          规则3
         *              如果因为队列为空而不能执行规则2,则搜索结東
         *      因此,需要首先访问所有与A邻接的顶点,并在访问的同时把它们插入到队列中。现在已经访
         * 问了A、B、C、D和E。这时队列(从头到尾)包含BCDE
         *      已经没有未访问的且与顶点A邻接的顶点了,所以从队列中取出B,寻找那些和B邻接的顶点。
         * 这时找到F,所以把F插入到队列中。已经没有未访问的且与顶点B邻接的顶点了,所以从队列中
         * 取出C,它没有未访问的邻接点,因此取出D并访问G。D没有未访问的邻接点,所以取出E。现
         * 在队列中有FG。再取出F,访问H。然后取出G,访问I
         * 现在队列中有H,但当取出它们时,发现没有其他的未访问顶点,这时队列为空,所以从过程
         * 中退出。
         *      在每一时刻,队列所包含的顶点是那些本身已经被访问,而它的邻居还有未被访问的顶点。
         * (对比深度优先搜索,栈的内容是起始点到当前顶点经过的所有顶点。)顶点访问的顺序为
         * ABCDEFGHI。
         *      注意广度优先搜索和深度优先搜索的异同点。
         *      可以认为广度优先搜索就像往水中投入石块时,水波纹扩展的过程——对于喜爱流行病学的人
         * 来说,就好比流感细菌通过航空旅客从一个城市传播到另一个城市。首先是相距起始点只有一条边
         * (飞机航线)的所有顶点被访问,然后是相距两条边的所有顶点被访问,依此类推。
         */
        bfs();
        /**
         *      广度优先搜索有一个有趣的属性:它首先找到与起始点相距一条边的所有顶点,然后是与起始
         * 点相距两条边的顶点,依此类推。如果要寻找起始顶点到指定顶点的最短距离,那么这个属性非常
         * 有用。首先执行BFS,当找到指定顶点时,就可以说这条路径是到这个顶点的最短路径。如果有更
         * 短的路径,BFS算法就应该已经找到过它了。
         */
    }
    public static void bfs()
    {
        Graph theGraph = new Graph();
        theGraph.addVertex('A');    // 0  (start for bfs)
        theGraph.addVertex('B');    // 1
        theGraph.addVertex('C');    // 2
        theGraph.addVertex('D');    // 3
        theGraph.addVertex('E');    // 4

        theGraph.addEdge(0, 1);     // AB
        theGraph.addEdge(1, 2);     // BC
        theGraph.addEdge(0, 3);     // AD
        theGraph.addEdge(3, 4);     // DE

        System.out.print("BFS(breadth-first search) Visits: ");
        theGraph.bfs();             // breadth-first search
        System.out.println();
    }  // end main()

    public static void dfs()
    {
        Graph theGraph = new Graph();
        theGraph.addVertex('A');    // 0  (start for dfs)
        theGraph.addVertex('B');    // 1
        theGraph.addVertex('C');    // 2
        theGraph.addVertex('D');    // 3
        theGraph.addVertex('E');    // 4

        theGraph.addEdge(0, 1);     // AB
        theGraph.addEdge(1, 2);     // BC
        theGraph.addEdge(0, 3);     // AD
        theGraph.addEdge(3, 4);     // DE

        System.out.print("DFS(depth-first search) Visits: ");
        theGraph.dfs();             // depth-first search
        System.out.println();
    }  // end main()
}
