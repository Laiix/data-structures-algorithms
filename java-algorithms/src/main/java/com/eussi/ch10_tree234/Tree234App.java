package com.eussi.ch10_tree234;

import com.eussi.ch10_tree234.util.Tree234;

/**
 * @author wangxueming
 * @create 2020-02-22 19:38
 * @description
 */
public class Tree234App {
    /**
     *      在二叉树中,每个节点有一个数据项,最多有两个子节点。如果允许每个节点可以有更多的数据项
     * 和更多的子节点,就是多叉树( multiway tree)。本章第一部分将要介绍的2-3-4树,就是多叉树,它的
     * 每个节点最多有四个子节点和三个数据项
     *      因为几个原因,2-3-4树非常有趣。首先,它像红-黑树一样是平衡树。它的效率比红-黑树稍差,
     * 但编程容易。其次,更重要的是,通过学习2-3-4树可以更容易地理解B树。
     *      B-树是另一种多叉树,专门用在外部存储中来组织数据(外部的意思是主存储的外部;通常是
     * 指磁盘驱动器)。B树中的节点可以有几十或几百个子节点。本章结尾部分会讨论外部存储和B-树
     * 2-3-4树的介绍
     */

    public static void main(String[] args) {
        /**
         * 2-3-4树的介绍
         *      下面将介绍2-3-4树的特征。本章还会介绍2-3-4树和红-黑树的惊人的相似性。
         *      下图展示了一棵小2-3-4树。每个节点可以保存一个、两个或三个数据项。
         *                                   |50| | |
         *                   /                                   \
         *              |30| | |                             |60|70|80|
         *           /        \              /           /           \                 \
         *     |10|20| |   |40| | |       |55| | |    |62|64|66|      |75| | |      |83|86| |
         *      图中上面的三个节点有子节点,底层的六个节点都是叶节点,没有子节点2-3-4树中所有的
         * 叶节点总是在同一层上。
         *
         * 名字的含义?
         *      2-3-4树名字中的2、3和4的含义是指一个节点可能含有的子节点的个数。对非叶节点有三种
         * 可能的情况
         *       - 有一个数据项的节点总是有两个子节点。
         *       - 有两个数据项的节点总是有三个子节点。
         *       - 有三个数据项的节点总是有四个子节点
         *      简而言之,非叶节点的子节点数总是比它含有的数据项多1。或者,用符号表示这个规则,设
         * 子节点链接的个数是L,数据项的个数是D,那么
         *      L=D+1
         *      这个重要的关系决定了2-3-4树的结构。比较来说,叶节点没有子节点,然而它可能含有一个、
         * 两个或三个数据项。空节点是不会存在的。
         *      因为2-3-4树最多可以有四个子节点的节点,也可以称它为4叉树。
         *      为什么不称2-3-4树为1-2-3-4树呢?它的节点不能像二叉树中那样只有一个子节点吗?因为二
         * 叉树的每个节点最多有两个子节点,所以二叉树(第8章“二叉树”和第9章“红-黑树”讲过的)
         * 可以称为二叉的多叉树。但是,二叉树和2-3-4树有一点不同(除了节点的最大子节点个数之外)
         * 二叉树中,节点最多有两个子节点的链接。它当然可以只有一个链接,指向它的左子节点或右子
         * 节点。它的另一个链接可以是null值。然而,在2-3-4树中,不允许只有一个链接。有一个数据项
         * 的节点必须总是保持有两个链接,除非它是叶节点,在那种情况下没有链接
         *      如图所示。有两个链接的节点称为2-节点,有三个链接的称为3-节点,有四个链接的称
         * 为4-节点,但没有称为1-节点的节点。
         *                  /
         *             |25| | |                             <-- 2-节点
         *           /        \
         *     |12| | |    |33|37| |
         *
         *                         /
         *                   |40|62| |                      <-- 3-节点
         *           /         \           \
         *     |27|33| |   |51|55|59|  |83| | |
         *
         *                              /
         *                         |50|75|95|                <-- 4-节点
         *           /          /          \           \
         *     |30|35| |   |55| | |  |78| | |     |100|105| |
         *
         * 2-3-4树的组织
         *      为了方便起见,用从0到2的数字给数据项编号,用0到3给子节点链编号。节点中的数据项按关键
         * 字值升序排列,习惯上从左到右升序(小数到大数)。
         *      树结构中很重要一点就是它的链与自己数据项的关键字值之间的关系。二叉树中,所有关键字
         * 值比某个节点值小的节点都在这个节点左子节点为根的子树上,所有关键字值比某个节点值大的节
         * 点都在这个节点右子节点为根的子树上。2-3-4树中规则是一样的,还加上了以下几点
         *       - 根是 child0的子树的所有子节点的关键字值小于key0。
         *       - 根是 child1的子树的所有子节点的关键字值大于key0并且小于key1
         *       - 根是 child2的子树的所有子节点的关键字值大于key1并且小于key2
         *       - 根是 child3的子树所有子节点的关键字值大于key2。
         *      2-3-4树中一般不允许出现重复关键字值,所以不用考虑比较相同的
         * 小的节点A、B间的节点B、C间的节点C大的节点
         *      所有的2-3-4树中,叶节点都在同一层(最底层)。上面层的节点一般都不满:也就是说,它们可能
         * 只含有一个或两个数据项,而不是三个。
         *      同样,注意树是平衡的。即使插入一列升序(或降序)排列的数据2-3-4树都能保持平衡。2-3-4
         * 树的自我平衡能力取决于新节点的插入方式,后面将会看到。
         *
         * 搜索2-3-4树
         *      查找特定关键字值的数据项和在二叉树中的搜索例程相类似。从根开始,除非查找的关键字值
         * 就是根,否则选择关键字值所在的合适范围,转向那个方向,直到找到为止
         *
         * 插入
         *      新的数据项总是插在叶节点里,在树的最底层。如果插入到有子节点的节点里,子节点的编号
         * 就要发生变化以此来保持树的结构,这保证了节点的子节点比数据项多1
         *      2-3-4树中插入节点有时比较简单,有时相当复杂。无论哪一种情况都是从查找适当的叶节点
         * 开始的
         *      査找时没有碰到满节点时,插入很简单。找到合适的叶节点后,只要把新数据项插入进去就可
         * 以了。
         *      插入可能会涉及到在一个节点中移动一个或者两个其他的数据项,这样在新数据项插入后关键
         * 值仍保持正确的顺序。
         *
         * 节点分裂
         *      如果往下寻找要插入位置的路途中,节点己经满了,插入就变得复杂了。发生这种情况时,节
         * 点必须分裂(split)。正是这种分裂过程保证了树的平衡。这里讨论的2-3-4树的是一种称为自顶向
         * 下的(top-down)2-3-4树,因为是在向下找到插入点的路途中节点发生分裂
         *      把要分裂节点中的数据项设为A、B和C。下面是分裂时的情况。(假设正在分裂的节点不是根
         * 后面会讲解根的分裂方法。)
         *       - 创建一个新的空节点。它是要分裂节点的兄弟,在要分裂节点的右边。
         *       - 数据项C移到新节点中。
         *       - 数据项B移到要分裂节点的父节点中。
         *       - 数据项A保留在原来的位置上。
         *       - 最右边的两个子节点从要分裂节点处断开,连到新节点上
         *      下图中显示的是一个节点分裂的例子。另一种描述节点分裂的方法是说4-节点变成两个2
         * 节点。
         *                                   |62| | |
         *                   /                                   \
         *              |29| | |                              |83|92|104| (|A|B|C|)
         *           /        \              /             /           \                \
         *     |15|21| |   |47| | |       |74| | |    |87|89| |      |97| | |      |112| | |
         *
         *                                  插入99后：
         *
         *                                   |62|92| |   <-- B
         *                   /                   \                         \
         *              |29| | |               |83| | |  <-- A          |104| | |  <-- C
         *           /        \                /     \               /           \
         *     |15|21| |   |47| | |       |74| | |  |87|89| |     |97|99| |      |112| | |
         *
         *      注意节点分裂是把数据向上和向右移动。正是这样的重新排列才可以保持树的平衡。
         *      插入只霱要分裂一个节点,除非插入路径上存在不止一个满的节点。这种情况就需要多重分
         * 裂。
         *
         * 根的分裂
         *      如果一开始查找插入点时就碰到满的根时,插入过程更复杂一点。类似于上面介绍的节点分裂，只不过需要在上面加一层根。
         *       - 创建新的根。它是要分裂节点的父节点。
         *       - 创建第二个新的节点。它是要分裂节点的兄弟节点。
         *       - 数据项C移到新的兄弟节点中
         *       - 数据项B移到新的根节点中
         *       - 数据项A保留在原来的位置上
         *       - 要分裂节点最右边的两个子节点断开连接,连到新的兄弟节点中
         *      以上过程中创建新的根,比旧的高一层。因此,整个树的高度就增加了1。另一种描述根分裂的方法是说4-节点变成三个2-节点。
         *      然后，顺着分裂的节点,继续向下查找插入点。
         *
         * 在下行路途中分裂
         *      注意,因为所有满的节点都是在下行路途中分裂的,分裂不可能向回波及到树上面的节点。任
         * 何要分裂节点的父节点肯定不是满的,因此该节点不需要分裂就可以插入数据项B。当然,如果父
         * 节点的子节点分裂时它已经有两个子节点了,它就变满了。但是,这只是意味着下次查找碰到它时
         * 才需要分裂。
         */
        testTree234();

        /**
         * 2-3-4树和红黑树
         *      2-3-4树和红黑树(第9章讲的)看上去可能完全不同。但是,在某种意义上它们又是完全相
         * 同的。一个可以通过应用一些简单的规则变成另一个,而且使它们保持平衡的操作也是一样的。数
         * 学上称它们为同构的。
         *      可能在实际应用时不需要把2-3-4树转变成红-黑树,但这种结构的等价性可以更清楚地表明它
         * 们的操作,并可以用于分析它们的效率。
         *      在历史上,2-3-4树先被提出:后来红黑树由它发展而来
         *
         * 2-3-4树转变为红黑树
         *      应用三条规则可以把2-3-4树转化成红黑树(WXYZ分表代表一个节点的四棵子树）
         *       - 把2-3-4树中的每个2-节点转化成红黑树的黑色节点
         *       - 把每个3-节点转化成一个子节点和一个父节点。子节点有两个自己的
         * 子节点:W和Ⅹ或Ⅹ和Y。父节点有另一个子节点:Y或W。哪个节点变成子节点或父
         * 节点都无所谓。子节点涂成红色,父节点涂成黑色。
         *       - 把每个4-节点转化成一个父节点和两个子节点。第一个子节点有它自
         * 己的子节点W和X;第二个子节点拥有子节点Y和Z。和前面一样,子节点涂成红色,
         * 父节点涂成黑色。
         *      下图展示了一棵2-3-4树和应用这些规则转化后对应的红黑树。转化后自动符合红黑树的规则。
         * 可以检验一下:两个红节点不会相连,每条从根到叶节点(或空子节点)的路径上黑节点的个数都是一样的
         *                                      |37| | |
         *                       /                                   \
         *                  |30|34| |                              |48|60|62|
         *           /        \        \              /             /          \           \
         *     |5| | |   |32|33| |   |35| | |      |40| | |    |50|53|57|   |69| | |    |86|98| |
         *
         *                         2-3-4树 <--> 红-黑树
         *
         *                           37(black)
         *                  /                     \
         *             34(black)                 60(black)
         *           /           \          /                 \
         *         30(red)    35(black)   48(red)            82(red)
         *      /      \                 /      \           /      \
         *  5(black) 32(black)    40(black)  53(black)  69(black) 96(black)
         *               \                    /      \            /
         *            33(red)              50(red) 57(red)    86(red)
         *      注意上面的2-节点，可以有两种形式的转换，都可以。
         *      可以说,2-3-4树中的3-节点等价于红黑树中有一个红色子节点的父节点,4-节点等价于有两
         * 个红色子节点的父节点。红-黑树中有一个黑色子节点的黑色节点不对应2-3-4树中的3-节点:它只
         * 表示有另一个2-节点子节点的2-节点。同样,有两个黑色子节点的黑色父节点也不代表4-节点。
         *
         * 操作的等价性
         *      不仅红-黑树的结构与2-3-4树对应,而且两种树的操作也是一样的。2-3-4树中用节点分裂保
         * 持平衡。红黑树中两种保持平衡的方法是颜色交换和旋转
         *  - 4-节点分裂和颜色变换
         *      在2-3-4树中向下为一个新节点寻找插入点时,把每个4节点分裂成两个2节点。红黑树中利
         * 用颜色变换。这两个操作怎么是等价的呢?
         *      下图中是2-3-4树中的一个4-节点在分裂前的样子。4-节点的父节点2-节点变成了3-节点。
         *
         *                     /                4-节点分裂                 /
         *                |70| | |                                    |50|70| |
         *              /        \                               /    B  \        \
         *        |40|50|60|    |80| | |                   |40| | |   |60| | |    |80| | |
         *        /A /B\ C \                               /A\        /C\
         *      下图中展示了与上图中的2-3-4树等价的红黑树。
         *      颜色变化后得到如下图所示的红黑树。现在节点40和60是黑色的,节点50是红色的。因此
         * 节点50和它的父节点对应于3-节点。这和上图中通过节点分裂得到的3-节点是一样的。
         *                      /                                    /
         *                   70(black)                            70(black)
         *                /            \                       /            \
         *         50(black)        80(black)             50(red)        80(black)
         *          /      \                             /      \
         *     40(red)   60(red)                    40(black)   60(black)
         *      因此,在2-3-4树的插入过程中分裂4-节点与红黑树的插入过程中的颜色变换是等价的。
         *  - 3-节点分裂和旋转
         *      2-3-4树中的3节点要转化成等价的红-黑树中的节点时,有两种可能的排列方式,如前面所述。两个数据
         * 项中的任何一个都可以成为父节点。选定一个做父节点后,子节点可以是左子节点或者是右子节点,就是说连接
         * 父节点和子节点的斜线可以向左斜或向右斜。
         *      这两种排列都是允许的:但是它们对保持树的平衡来说作用可能不一样。在稍大的范围内来讨
         * 论这个问题
         *      下图中是一棵2-3-4树,应用转换规则从2-3-4树得到的等价红黑树。它们之间的不同是选择3-节点的两个
         * 数据项中的哪个来做父节点。
         *                                           /
         *                                      |70|80| |
         *                                /        \          \
         *                          |40|50|60|    |75| | |   |80| | |
         *                          / / \ \       / \        / \
         *
         *              左倾                       /
         *                                      80(black)
         *                                   /            \
         *                              70(red)        85(black)
         *                           /          \
         *                     50(black)        75(black)
         *                      /      \        /    \
         *                 40(red)   60(red)
         *
         *              右倾                       /
         *                                      70(black)
         *                                   /            \
         *                            50(black)           80(red)
         *                           /        \          /       \
         *                    40(red)      60(red)  40(black)   60(black)
         *                    /    \       /    \     /   \       /   \
         *      虽然这些排列方法都是允许的,但可以看到左倾的树是不平衡的,右倾中则是平衡的。对左倾
         * 中的红黑树,可以向右旋转(并进行颜色变幻)来保持平衡。令人惊异的是,旋转得到的树和c)
         * 中的树是一样的。
         *      因此,红-黑树中的旋转和把2-3-4树转换成红-黑树时选择哪个节点做父节点是等价的。虽然
         * 没有提及,但对子孙节点中需要进行两次旋转时,也是等价的。
         *
         * 2-3-4树的效率
         *      分析23-4树的效率比红黑树要困难,但还是可以从两者的等价性开始分析。
         *
         * 速度
         *      如第8章所示,查找过程中红黑树每层都要访问一个节点,可能是查找已经存在的节点,也
         * 可能是插入一个新节点。红黑树的层数(平衡二叉树)大约是log2(N+1),所以搜索时间与层数成
         * 比例
         *      2-3-4树中同样要访问每层的一个节点,但2-3-4树比有相同数据项的红黑树短(层数少)。参
         * 考上图可以看得出。
         *      更特别的是,2-3-4树中每个节点最多可以有4个子节点。如果每个节点都是满的,树的高
         * 度应该和log4(N)成正比。以2为底的对数和以4为底的对数底数相差2。因此,在所有节点都满
         * 的情况下,2-3-4树的高度大致是红-黑树的一半。不过它们不可能都是满的,2-3-4树的高度就
         * 大致在log2(N+1)和log2(N+1)2之间。减少2-3-4树的高度可以使它的查找时间比红黑树的短
         * 一些。
         *      另一方面,每个节点要查看的数据项就更多了,这会增加查找时间。因为节点中用线性搜索来
         * 查看数据项,使查找时间增加的倍数和M成正比,即每个节点数据项的平均数量。总的查找时间和
         * M*log4(N)成正比。
         *      有些节点有一个数据项,有些有两个,有些有三个。如果按平均两个来计算,查找时间和2*Log4(N)
         * 成正比。在大O表示法中这个小的常数可以忽略。
         *      因此,2-3-4树中增加每个节点的数据项数量可以抵偿树的高度的减少。2-3-4树中的查找时间
         * 与平衡二叉树如红黑树大致相等,都是O(logN)。
         *
         * 存储需求
         *      2-3-4树中每个节点保存三个数据项的引用和四个子节点的引用。这些空间可以用数组的形式
         * ,或者用单独的变量。这些存储空间不是都有用的。只有一个数据项的节点会
         * 浪费2/3的数据项存储空间和1/2的子节点的存储空间。两个数据项的节点就浪费了1/3的数据项存
         * 储空间和1/4的子节点存储空间;换一种说法,它只利用了5/7的可用空间
         *      平均按每个节点有两个数据项来计算,大约有2/7的存储空间浪费了
         *      可能会想到用链表来代替数组以保存子节点和数据的引用。但对只有三个或四个数据项来说
         * 链表的额外开销和数组比起来,用链表也许并不是一个值得用的方法
         *      因为红黑树是平衡的,所以没有几个节点只有一个子节点,因此几乎所有子节点引用的存储
         * 空间都利用了。同样,每个节点都保存了一个数据项的最大项数值。这使红黑树在存储上比2-3-4
         * 树利用率更高。
         *      Java中,存储对象的引用而不是对象本身,在2-3-4树和红黑树之间这个存储差异并不重要
         * 而且对2-3-4树编程当然更容易些。但是,在不是用保存引用这种方法的编程语言中,2-3-4树和红
         * 黑树间存储的效率差异可能就很显著了
         *
         * 2-3树
         *      下面将简单地讨论一下2-3树,因为在历史上它很重要,并且在很多应用程序中还在应用。同
         * 时,一些用于2-3树的技术会在B-树中应用，下面将要学习到B-树。最后,因为仅仅修改了每个
         * 节点的子节点数目就会使树的算法有很大的变化,这个问题很有趣。
         *      2-3树和234树类似,除了从名字中就可以猜到的不同之处,2-3树的节点比2-3-4树少存
         * 个数据项和少一个子节点。2-3树是第一种多叉树,由 J.E.Hopcroft在1970年发明。B-树(2-3-4树
         * 是它的特例)直到1972年才发明。
         *      2-3树的操作在很多方面都和2-3-4树类似。节点可以保存1个或2个数据项,可以有0个,1
         * 个、2个或3个子节点。其他的方面,父节点和子节点的关键字值的排列顺序是和2-3-4树一样的
         * 向节点插入数据项简单一些,因为需要的比较和移动次数少了。和2-3-4树中一样,所有新数据项
         * 都插入到叶节点中去,而且所有的叶节点都在树的最底层
         *
         * 节点分裂
         *      查找一个存在的数据项的方法和2-3-4树一样,只是数据项和子节点的数量不一样。可能会认
         * 为插入过程也和2-3-4树类似,但分裂节点的过程有很大的不同。
         *      下面来看为什么分裂过程那么不同。在这两种树中,无论哪一种树节点进行分裂都需要三个数
         * 据项:一个保留在要分裂的节点里,一个右移到新的节点里,还有一个要上移到父节点里。2-3-4
         * 树中一个满的节点有三个数据项,它们都各自移到自己的位置中去。但是,在2-3树中满的节点只
         * 有两个数据项,到哪里去找第三个数据项呢?因此必须要用到新的数据项:即要插入到树中的数据
         * 项
         *      2-3-4树中在所有分裂完成之后才插入新数据项。2-3树中新的数据项必须参与分裂过程。它必
         * 须要插入到叶节点中去,这就不可能在下行路途中进行分裂。如果新数据项要插入的叶节点不满,
         * 新数据项可以立即插入进去,如果叶节点满了,该节点就得分裂。该节点的两个数据项和新数据项
         * 分在这三个节点里:已存在的节点、新节点和父节点。如果父节点不是满的,操作就完成了(在连
         * 接新节点之后)。如下图所示：
         *             |75| |                       |75|85|
         *           /       \                  /       \       \
         *     |70|80|     |80|90|        |70| |     |80| |    |90| |
         *      但是,如果父节点是满的,父节点也必须要分裂。它的两个数据项和自己分裂的子节点传上来
         * 的数据项必须分配到父节点,父节点的新的兄弟节点,以及父节点的父节点中去。这种情况如图1018
         * 所示。
         *      如果父节点的父节点(叶节点的祖父节点)是满的,还是要分裂。分裂过程向上延续直到找到
         * 不满的父节点或者遇到根。如果根也是满的,就要创建一个新的根作为原来的根的父节点,如下图：
         *             |50| |                                      |50|85|
         *           /       \                         /            \             \
         *                |80|90|                                |75| |          |95| |
         *            /       \      \                          /     \        /        \
         *        |70| |   |80| |   |90|95|                |70| |   |80| |   |90| |   |100| |
         *
         * 实现
         *      Java完整地实现2-3树留作练习，见excise。但是,最后还是来提示一下如何处理分裂地过程
         * 这只有一个方法(还有一种方法允许每个节点保存一个假的第四个子节点)
         *      向下插入过程的例程不理会遇到的节点是满还是不满。它顺着树向下查找直到找到要插入的叶
         * 节点。如果叶节点不满,就插入新的值。但是,如果叶节点满了,需要重新整理树来挪出位置。要
         * 做这件事,需要调用 split方法。传入这个方法的参数是满了的叶节点和新的数据项。它会负责分
         * 裂这个节点并把新节点插入到新的叶节点里
         *      如果 split方法发现叶节点的父节点也是满的,它递归调用自己来分裂父节点。 split方法一直
         * 调用自身,直到找到不满的叶节点或找到根为止。split的返回值是新的右节点,它可以被前面调
         * 的 split方法应用
         *      由于几个因素,编写分裂过程的代码是很复杂的。首先,2-3-4树中三个要分开的数据项是已
         * 经有序的,但2-3树中新数据项的关键字值必须和其他两个叶节点中的数据项比较;然后根据比较
         * 结果分配这三个数据项。
         *      另外,分裂父节点会创建第二个父节点,所以现在有一个左父节点(原来的)和一个新的右父
         * 节点。需要把连到一个父节点上的三个子节点的连接,变成两个父节点每个有两个子节点的状态
         * 这里有三种情况,取决于哪个子节点(0,1或2)要分裂。如下图(d表示删除，n表示新建)：
         *      插入45，分裂child0:
         *                |60|80|                                         |60| |
         *            /       \d      \d                            /n            \n
         *        |40|50|   |70| |   |90| |                     |45| |          |80| |
         *                                                     /     \n       /n       \n
         *                                                |40| |   |50| |   |70| |   |90| |
         *
         *      插入73，分裂child1:
         *                |60|80|                                        |73| |
         *            /       \      \d                             /n             \n
         *        |40| |   |70|75|   |90| |                     |60| |          |80| |
         *                                                     /     \        /n       \n
         *                                                |40| |   |70| |   |75| |   |90| |
         *
         *      插入93，分裂child2:
         *                |60|80|                                        |80| |
         *            /       \      \d                             /n             \n
         *        |40| |   |70| |   |90|95|                     |60| |          |93| |
         *                                                     /     \        /n       \n
         *                                                |40| |   |70| |   |90| |   |95| |
         *
         * 外部存储
         *      2-3-4树是多叉树的例子,多叉树是指节点的子节点多于两个并且数据项多于一个。另一种多
         * 叉树,B-树,尚在外部存储器上的数据时,它起很大作用。外部存储特指某类磁盘系统,例如在大
         * 多数台式电脑或服务器中都有的硬盘
         *      接下来将从讨论外部文件管理的各种问题开始。用简单的方法来组织外部数据:即用顺序有序
         * 排列的方法。最后,学习B-树,并解释为什么它和磁盘文件配合的那么好。本节以另一种外部存储
         * 的方法—“索引”来结束,这种方法可以单独使用也可以和B-树一起用
         *      还要涉及外部存储的其他方面,例如检索技术。下一章会提到另一种外部存储的方法:哈
         * 希化。
         *      外部存储技术实现的细节跟操作系统、语言,甚至和装置的硬件密切相关。因此,本节的讨论
         * 相比本书中的其他问题来说是相当概括的。
         *
         * 访问外部数据
         *      到目前为止所讲过的数据结构都是假设数据存储在主存中的(通常称为RAM,随机访问存储
         * 器)。但是,在很多情况下要处理的数据数量太大,不能都存储在主存中。这种情况下需要另一种
         * 存储方式。磁盘文件存储器一般比主存大得多;这使得存储每字节的花费比较低
         *      当然,磁盘还有另一个好处:它们的持久性。关掉计算机的时候(或者是断电了),在主存中
         * 的数据会丢失。磁盘文件存储器突然断电后还可以保存数据。但是,这里讨论的主要还是存储容量
         * 方面的差异
         *      外部存储的缺点是它比主存慢得多。由于速度不同因此需要用不同的技术来有效地管理它们。
         *      作为外部存储的一个例子,假设编写一个数据库程序来管理一个中等规模城市的电话簿的数据
         * 可能有50000条记录。每条记录包括姓名、地址、电话号码以及电话公司内部使用的各种其
         * 他数据。每条内容存储为一条记录,长度为512字节。则文件大小是500000×512,25600000
         * 字节,即256M。假设对计算机内存来说它太大以至于存储不下,不过磁盘驱动器足够大可以存
         * 储它。
         *      因此，在磁盘驱动器中保存了大量数据。怎样组织它们来实现下列这些有用的特点:快速查找、
         * 插入和删除呢?
         *      为了找到答案,需要牢记两条。第一,在磁盘驱动器中访问数据比在主存中要慢得多，第二，一
         * 次需要访问很多记录。下面来看这些特点
         *  - 非常慢的存储
         *      计算机的主存按电子的方式工作。几微秒(一秒的百万分之一)就可以访问一个字节。
         *      在磁盘驱动器上存取要复杂多了。在旋转的磁盘上数据按照圆形的磁道排列,有点像压缩光盘
         * (CD)或老式的留声机唱片的轨道。
         *      要访问磁盘驱动器上的某段数据,读写头要先移到正确的磁道。通过步进的电动机或类似的设
         * 备完成;这样的机械运动需要好几毫秒(一秒的千分之几)
         *      一旦找到正确的磁道,读写头必须要等待数据旋转到正确的位置。平均来说,这一步要旋转半
         * 圈。即使磁盘每分钟转10000圈,那么在读到数据前还需要3毫秒。读写头就位后,就可以进行实
         * 际的读/写操作了;这可能还需要几毫秒
         *      因此,通常磁盘存取的时间大约是10毫秒。大约比访问主存慢了1000倍
         *      每年都会发展新技术来减少磁盘存取的时间,但主存访问的时间减少得更快,所以磁盘存取和
         * 主存存取的时间差距将来会越来越大
         *  - 一次访问一个数据块
         *      当读写头到达正确的位置后开始读(或写)过程,驱动器可以很快地把大量数据转移到主存中。
         * 因为这个原因,为了简化驱动器的控制装置,在磁盘上的数据按块存储,根据系统的不同称为块
         * 页、分配单元,或其他的名字。这里称它们为块。
         *      磁盘驱动器每次最少读或写一个数据块的数据。块的大小根据操作系统,磁盘驱动器的容
         * 量,以及其他因素而不同,但它总是2的倍数。在电话本的例子里,可以假设一个数据块的容
         * 量是8192字节(2^13)。因此,电话本数据库中需要25600000节分为8192字节每块,一共是
         * 31250块。
         *      在读/写操作时如果按块容量的倍数来操作是效率最高的。如果要读100字节,系统读取一块
         * 8192字节,只留下100字节,把其他的都扔了。或者如果要读8200字节,它会读两块,或者说16284
         * 字节,并把几乎一半的内容都扔了。通过组织软件使它每次操作一块数据,可以优化性能。
         *      假设电话本记录的大小是512字节,在一块中存储16条记录(8192除以512),如图1022所
         * 因此,效率最高的情况是一次读取16条记录(或这个数字的倍数)。
         *      注意让记录的大小是2的倍数也是很有用的。这样做,每块可以正好装下整数个记录。
         * 当然,在这个电话本的实例中,记录,块和其他的数据的大小都只是示例性的:它们会根据记
         * 录的数目和大小,以及其他软件和硬件的限制等有很大的不同。通常一块中保存成百上千个记录
         * 记录可能比512字节大也可能小。
         *      一旦读写头已经就位,读取一块是相当快的,只需要几亳秒。因此,磁盘存取时读或写一
         * 块的时间与块的容量关系不大。块越大,读或写一条记录的效率越高(假设用到的记录都在
         * 块里)
         *
         * 顺序有序排列
         *      排列电话本数据的一种方法是在磁盘文件中按照某个关键字为所有的记录排序,如按照姓的字
         * 典序。 Joseph Aardvark记录可能会是第一个,依次类推。
         *  - 查找
         *      在顺序有序排列的文件中查找某个姓的记录,如 Smith,可以用二分查找方法。需要从读取
         * 块记录处于中间位置的记录开始。在主存中有8192字节的缓冲区,一次把一块中的16个记录都读
         * 到缓冲区里。
         *      如果这些记录的关键字在字典序中位置靠后(例如, Keller),就到文件的3/4处( Prince)来
         * 读取那里的一块;如果关键字靠前,就到文件的14处( DeLeon)读取。不断地把范围缩小一半,
         * 最后会找到要找的记录
         *      第2章中已经说过在主存中的二分查找的要执行log2(N)次比较,对50000个数据项就是大约
         * 19次比较。如果每次比较要10微秒,总共就是190微秒,即大约一秒的2/1000,比眨一下眼睛还
         * 要快。
         *      但是,现在处理的数据存储在磁盘上。因为每次磁盘存取都很耗时,所以更重要的是要注意需
         * 要访问多少次磁盘,而不是有多少独立的记录。读取一块记录的时间比在内存的16个记录中查找
         * 的时间要长得多
         *      磁盘存取比内存存取慢得多,但另一方面一次访问一块,块数比记录数要少得多。在上面的例
         * 子中,有31250块。它取2的对数大约是15,所以理论上大约需要存取15次磁盘来找到要找的记
         * 录
         *      实际上这个数字还要小一点,因为一次可以读取16条记录。在二分查找开始的阶段,内存中
         * 有多条记录并没有什么帮助,因为下一次存取会在文件中的较远的部分。但在离要找的记录很近的
         * 时候,要找的下一条记录可能已经在内存中了,因为它可能在这个块的16条记录里。这可能会减
         * 少了大约两次的读盘次数。因此,只需要大约13次磁盘存取(15-2),每次访问需要10毫秒,总
         * 共需要130毫秒,即1/7秒。这比内存访问要慢得多,但还不算太差。
         *  - 插入
         *      不幸的是,要在顺序有序排列的文件插入(或删除)一个数据项时情况要糟糕得多。因为数据
         * 是有序的,这两个操作平均都需要移动一半的记录,因此要移动大概一半的块。
         *      移动每块都需要存取两次磁盘:一次读和一次写。找到插入点时,把包含插入点的数据块读入
         * 到存储缓冲区中。块中最后一条记录保存住,移动适当数目的记录为要插入的新记录腾地方。之后
         * 就把缓冲区的内容写回到磁盘中去
         *      下一步,第二块读到缓冲区中。保存它的最后一条记录,这块所有其他记录都移动,上一块的
         * 最后一条记录插入到缓冲区的开始处。之后缓冲区的内容再写回到磁盘中去。这个过程一直继续,
         * 直到所有在插入点后面的记录都重写过为止
         *      假设有31250块,需要读和写(平均)15625块,每次读和写需要10毫秒的话总共要用5分钟
         * 来插入一条记录。如果要在电话本中插入上干条新名字,这显然太不理想了
         *      顺序有序排列的另一个问题是,如果它只有一个关键字,速度还比较快;比如这里的文件是按
         * 照姓排序的。但是假设需要查找某个电话号码,就不能用二分查找,因为数据是按姓排序的。这就
         * 得査找整个文件,用顺序访问的方法一块一块地找。这样查找需要读取平均一半的块,大约会需要
         * 2.5分钟,对一个简单的查找来说也是非常糟糕的。所以要寻找一种更有效的方法来保存磁盘中的
         * 数据
         *
         * B-树
         *      怎样保存文件中的记录才能够快速地查找、插入和删除记录呢?前面已经讲过树是组织内存数
         * 据的一个好方法。那么树可以应用于文件吗?
         *      当然可以,但对外部数据需要用和内存数据不一样的树。这种树是多叉树,有点像2-3-4树,
         * 但每个节点有更多的数据项;称它为B-树。1972年R. Bayer和E. M. McCreight首先提出用B-树作
         * 为外部存储的数据结构。(严格地说,2-3树和2-3-4树分别是B树的3节点和4节点的特例,但是
         * B-树通常更强调每个节点含有很多的子节点。)
         *  - 每节点一块
         *      为什么每个节点有那么多数据项呢?前面已经讲过一次读或写一块内的数据时效率最高。在树
         * 中,包含数据的实体是节点。把一整块数据作为树的节点是比较有意义的。这样做,读取一个节点
         * 可以在最短时间里访问最大数据量的数据。
         *      一个节点中可以放多少数据呢?在电话本的例子里,每条数据记录512字节,可以把16条记
         * 录放在一个8192字节的块中
         *      但是在树中,还需要保存节点间的链接(就是链接到其他块去,因为一个节点对应一个块)。
         * 前面章节已经讨论过,在内存中的树里,这些链接是引用(或像C++这样的语言里的指针),指向
         * 内存中其他部分的节点。在磁盘文件中存储的树,链接是文件中的块的编号(在电话本的例子中从
         * 0到31249)。可以用一个int型的字段保存块号码,int是4字节类型,可以保存20亿以上的块号码
         * 基本上对大多数的文件都够用了。
         *      现在不再把16x512字节的记录挤到一块中去了,因为需要空间来保存指向子节点节点的引用
         * 把块中记录的数量减少到15这样就有地方来保存链接了,不过更高效的方法是每个节点保存偶数
         * 个记录,这样(在恰当地分配管理后),把记录大小减少为507字节。将有17个子节点链接(比数
         * 据项个数多1),这样链接需要68字节(17×4)。这样16x507字节的记录填进块中后,还留下12字
         * 节的空间(507×16+68=8180)。树中一个节点对应一块。
         *      在每个节点中数据是按关键字顺序有序排列的,像2-3-4树一样。实际上,B-树的结构很像2-3-4
         * 树,只是每个节点有更多的数据项和更多的指向子节点的链接。B-树的阶数由节点拥有最多的子节
         * 点数决定。在这个例子里是17,所以这个树是17阶B树。
         *  - 查找
         *      在记录中按关键字查找和在内存的2-3-4树中查找很类似。首先,含有根的块读入到内存中。
         * 然后搜索算法开始在这15个节点中査找(或者,如果块不满的话,有多少块就检查多少块),从0
         * 开始。当记录的关键字比较大时,需要找在这条记录和前一条记录之间的那个子节点。
         * 持续这个过程直到找到正确的节点。如果到达叶节点还没有找到那条记录,则查找不成功
         *  - 插入
         *      B-树中的插入过程更像2-3树,而不是2-3-4树。回忆一下2-3-4树有很多节点不满,实际上有
         * 的只有一个数据项。尤其是每次节点分裂时总会产生两个每个有一个数据项的节点。在B-树中这不
         * 是最好的方法
         *      尽可能让B-树节点满是非常重要的,这样每次存取磁盘时,读取整个节点,就可以获得最大数
         * 量的数据。为了达到这个目的,B-树的插入过程与2-3-4树的插入有下列三点不同
         *       - 节点分裂时数据项平分:一半到新创建的节点中去,一半保留在原来的节点中。
         *       - 节点分裂像2-3树那样从底向上,而不是自顶向下。
         *       - 同样,还是像2-3树一样,原节点内中间数据项不上移,而是加上数据项后所组成的节点
         * 数据项序列的中间数据项上移
         *      通过建立一棵小的B-树来示范插入过程中的这些规则,如下图所示。因为没有那么大的地
         * 方来显示每个节点中的实际有的记录的数量,所以节点中只有四个记录;因此,这是一棵5阶B-树
         *      下图中显示的是一个已经满了的根节点;数据项的关键字是20、40、60和80,它们已经
         * 插入到树中了。新的数据项70要插入,就导致节点分裂。下面是节点分裂的过程。因为是根要分
         * 裂,所以要创建了两个新节点(像2-3-4树一样):一个新的根和一个作为要分裂节点的右兄弟的新
         * 节点。
         *      为了决定新数据项要插在哪里,插入算法在内部缓冲区里把这5个的关键字排序。其中有4个
         * 关键字在要分裂的节点中,第5个是要插入的新数据项。这5个数据项序列显示在树的旁边。第一步
         * 显示的序列是20,40,60,70,80。
         *      在第一步序列里的中间数据项是60,它被提到新的根节点中。所有中间数据项左边的数据项
         * 留在分裂节点中,所有右边的移到右边新节点中，结果见下图。(在本章的电话本例子中,8个数据项
         * 会移到每个子节点中,而不是图中所示的两个。)
         *
         *                                            |60| | | |
         *   |20|40|60|80|     -->                /              \
         *                                 |20|40| | |       |70|80| | |
         *
         *      再插入两个数据项,10和30。它们填满了左子节点,如图下图所示。
         *
         *                           |60| | | |
         *                       /              \
         *                |10|20|30|40|       |70|80| | |
         *
         *      下一个要插入数据项15,则分裂这个左子节点,结果如下图所示。数据项20被上移到根中。
         *
         *                                |20|60| | |
         *                       /              \              \
         *                |10|15| | |       |30|40| | |       |70|80| | |
         *
         *      下一步,三个数据项——75、85和90——要插入到树里。前两个填满第三个子节点,第三个数
         * 据项使它分裂,需要建立新节点并把中间数据项80提升到根中。结果如下图所示。
         *
         *                                        |20|60|80| |
         *                       /              /              \                  \
         *                |10|15| | |       |30|40| | |       |70|75| | |     |85|90| | |
         *
         *      又是三个数据项——25、35和50——要插入树里。前两个填满第二个子节点,第三个使它分裂,
         * 需要建立新节点并把中间数据项35提升到根中。结果如下图所示。
         *
         *                                                |20|35|60|80|
         *                       /              /              \                  \                  \
         *                |10|15| | |       |25|30| | |       |40|50| | |      |70|75| | |      |85|90| | |
         *
         *      现在根已经满了。但是,随后的插入不需要分裂节点,因为只有新数据项要插入到一个满的节
         * 点时才需要分裂,而不是在树中向下查找时遇到满的节点就分裂。因此,22和27插入到第二个子
         * 节点里,而不需要节点分裂,如下图所示
         *
         *                                                |20|35|60|80|
         *                       /              /              \                  \                  \
         *                |10|15| | |    |22|25|27|30|       |40|50| | |      |70|75| | |      |85|90| | |
         *
         *      但是,下一个要插入的数据项32就导致了节点分裂;实际上是两个节点分裂。第二个子节点
         * 已经满了,所以它分裂,如图下图所示。但是这次分裂提出的数据项27,没有地方去,因为根也是满
         * 的。因此,根必须也分裂,最后的分配结果如下图所示。
         *
         *                                                       |35| | | |
         *                                       /                                         \
         *                                  |20|27| | |                                |60|80| | |
         *                       /              \            \                    /              \            \
         *                |10|15| | |    |22|25| | |     |30|32| | |        |40|50| | |   |70|75| | |    |85|90| | |
         *
         *      注意在整个这次插入过程中,没有任何一个节点(除了根)的数据项少于一半,并且很多都比
         * 一半要满。正如上面提到的,这样做使效率提高了,因为访问文件读一个节点时总是能存取尽可能
         * 多的数据。
         *
         * B-树的效率
         *      因为每个节点有那么多的记录,每层有那么多节点,因此在B-树上的操作非常快,这里假设数
         * 据都保存在磁盘上。在电话本的例子里有50000条记录。B树中所有的节点至少是半满的,所以
         * 每个节点至少有8条记录和9个子节点的链接树的高度因此比log9(N)小一点(N以9为底的对数)
         * N是500000结果为5972,这样树的高度大概是6层。
         *      因此,使用B-树只需要6次访问磁盘就可以在有50000条记录的文件中找到任何记录了。每
         * 次访问10毫秒,这就需要花费60亳秒的时间,即6/100秒。这比在顺序有序排列的文件中二分查
         * 找要快得多。
         *      节点中记录越多,树的层数就越少。实例中的B-树是6层,虽然节点只含有16条记录。相反,
         * 有50000个数据项的二叉树大约有19层,2-3-4树会有10层。如果块中有成百条记录,可以减少
         * 树的层数并且大大提高访问时间。
         *      虽然B树中的查找比在顺序有序排列的磁盘文件查找快,不过插入和删除操作才显示出B-树
         * 最大的优越性
         *      先假设在B-树中不需要节点分裂的插入情况。这种情况很少见,因为每个节点中会有大量的记
         * 录。在电话本实例中,已经看到只需要6次访问就可以找到插入点。之后还需要一次访问把保存了
         * 新插入记录的块写回到磁盘中去,一共是7次访问。
         *      接着来看看节点需要分裂的情况。要读入分裂的节点,它的一半记录都要移动,并且要写回磁
         * 盘。新创建的节点要写入磁盘,必须要读取父节点,然后插入上移的记录,写回磁盘。这里就有5
         * 次访问,加上找到插入点需要的6次访问,一共是12次。相比在访问顺序文件中插入数据项所需
         * 要的500000次访问这是大大地改进了。
         *      在其他的一些B-树里,只有叶节点保存数据。非叶节点只保存关键字和块的号码。这使得操作
         * 更快,因为每一块可以保存更多块的号码。这样的高阶树层数更少,访问速度也提高了。但是,编
         * 程可能会复杂一些,因为这里有两种节点:叶节点和非叶节点
         *
         * 索引
         *      另一种加快文件访问速度的方法是用顺序有序排列存储记录但用文件索引连接数据。文件索引
         * 是由关键字块对组成的列表,它按关键字排序。回忆一下电话本实例中有500000条512字节的记
         * 录,每块存16条记录,则有31250块。假设查找的关键字是姓,每条索引中有两个数据项
         *       - 关键字,比如 Jones
         *       - 块的号码, Jones在文件中的定位。这个号码的范围从0到31249
         *      用28个字节长度的字符串来保存关键字(足够保存最长的姓)以及4字节来保存块号码(Java
         * 语言中的int类型)。索引中的每个记录需要32字节。这只是每条记录大小的1/16
         *      索引中的记录根据姓按顺序有序排列。磁盘上原来那些记录可以按任何顺序有序排列。这就
         * 是说新记录可以简单地添加到文件末尾,这样记录按照插入时间排列。
         *
         * 内存中的文件索引
         *      索引比文件中实际记录小得多。它甚至可以完全放在内存里。在电话本实例中,有500000条
         * 记录。每一条在索引中的记录是32字节,这样索引的大小是32×500000字节,即1600000字节那
         * 么长(1.6兆)。把它放到现在的计算机的内存中不会有任何问题。索引可以保存在磁盘里,数据库
         * 程序启动后就读取到内存中来。这样,对索引的操作就可在内存中完成了。每天结束时(或更频繁
         * 也行),索引可以写回磁盘中永久保存
         *
         * 查找
         *      应用将索引放在内存中的方法,使得操作电话本的文件比直接在顺序有序排列记录的文件中执
         * 行操作更快。例如,二分查找需要19次索引访问。每次访问20微秒,这样只需要大约4/10000秒
         * 然后在索引中找到实际的记录块的号码后,(不可避免地)要花时间从文件中访问它。不过,这
         * 次访问磁盘的时间只需要10毫秒。
         *
         * 插入
         *      在索引文件中插入新数据项,要做两步。首先把这个数据项整个记录插入到主文件中去:然后
         * 把关键字和包括新数据项存储的块号码的记录插入到索引中
         *      因为索引是顺序有序排列的,要插入新数据项,平均需要移动一半的索引记录。设内存中2微
         * 秒移动一个字节,则需要250000乘以32再乘以2,大约要16秒来插入一个新记录。这比没有索引
         * 在顺序有序排列的文件插入一条新记录要5分钟还是快多了。(注意不需要移动主文件中的记录
         * 只要在文件末尾处添加了一条新纪录即可。)
         *      当然,可以用更复杂的方法在内存中保存索引。例如把它存为二叉树,2-3-4树,或红-黑树
         * 这些方法都大大减少了插入和删除的时间。每种情况下把索引存在内存中的方法都比文件顺序有序
         * 排列的方法快得多。有时比B-树都快
         *      在索引文件的插入过程中真正的磁盘访问包括插入新纪录本身。通常,把文件的最后一块
         * 读入到内存中来,把新纪录添加在后面,然后把这块写回到磁盘上去。这个过程只需要两次文
         * 件访问。
         *
         * 多级索引
         *      索引方法的一个优点是多级索引,同一个文件可以创建不同关键字的索引。在一个索引中关键
         * 字可以是姓;另一个索引中,是地址。索引和文件比起来很小,所以它并不会大量地增加数据存储
         * 量。当然,数据项从文件中删除的时候会麻烦一些,需要把所有索引中的那条索引记录删掉,但这
         * 里不讨论这个问题。
         *
         * 对内存来说索引太大
         *      如果索引太大,不能放在内存中,它就需要按块分开存储在磁盘上。对大文件来说把索引保存
         * 成B-树是很合适的。主文件中记录可以存成任何合适的顺序
         *      这种排列方法效率很高。把记录添加到主文件末尾很快,在索引中插入新记录的索引记录也很
         * 快,因为索引按树形存储。对大文件来说这样做查我和插入操作都很快
         *      注意索引按B-树存储时,每个节点保存n个子节点指针和n-1个数据项。子节点指针是索引中
         * 其他节点的块的号码。数据项保存关键字和指向主文件中一个块的指针。不要把这两种类型的块指
         * 针搞混
         *
         * 组合搜索条件
         *      组合搜索惟一可行的方法是顺序地读取文件中的每一块。假设电话本实例中要找一列记录,它
         * 们在电话本中名字都是 Frank,地址都是 Springfield,且电话号码中有三个7。(这好像是在一宗谋
         * 杀中,受害者手中抓着的胡乱涂写的残片上所显示的线索。）
         *      根据姓排列文件一点用也没有。甚至如果有索引文件,按名字和城市排序,也不能很方便地找
         * 到含有Frank和Springfield的记录。在这种情况下(在许多数据库中很常见),最快的方法可能就是
         * 顺序读取文件,一块块地检查每个记录看看它是否符合查找条件
         *
         * 外部文件排序
         *      归并排序是外部数据排序的首选方法。这是因为,这种方法比起其他大部分排序方法来说,磁
         * 盘访问更多的涉及临近的记录而不是文件中随机的部分
         *      回忆第6章“递归”中归并排序递归地调用它自身,来给越来越短的序列排序。一旦两个最小
         * 的序列(在内存执行的版本中是只有1字节)排好序,就把这两个合并成长一点的序列。越来越长
         * 的序列合并,直到最后整个文件有序
         *      外部存储的方法是相似的。不过最小的序列可能是从磁盘读取的一块中的一个记录。因此,需
         * 要两步过程
         *      第一步,读取一块,它的记录在内部排序,然后把排完序的块写回到磁盘中。下一块也同样排
         * 序并写回到磁盘中。直到所有的块内部都有序为止
         *      第二步,读取两个有序的块,合并成一个两块的有序的序列,再把它们写回到磁盘。下次,把
         * 每两块序列合成四块的序列。这个过程继续下去,直到所有成对的块都合并过了为止。每次,有序
         * 序列的长度增长一倍,直到整个文件有序。
         *      下图中是对一个外部文件归并排序的过程。文件含有四块,每块有四条记录,一共有16
         * 条记录。每次只能把三块读到内存中。(当然,这些容量在实际情况下会大得多。)下图a展示了
         * 排序前的文件;每条记录中的数字是它的关键字值。
         *             块           块            块         块
         *    a)    |14|9|11|2| |4|12|16|13| |3|15|10|5| |1|8|7|6|
         *
         *    b)    |2|9|11|14| |4|12|13|16| |3|5|10|15| |1|6|7|8|
         *
         *    c)    |2|4|9|11|12|13|14|16|    |1|3|5|6|7|8|10|15|
         *
         *    d)      |1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|
         *
         *  - 块的内部排序
         *      在第一步中文件中的所有块都在内部排序。把一块读入到内存中并且可以用任何内部排序的方
         * 法为它排序,如快速排序(或者是少量记录的希尔排序或插入排序)块内部排序后的结果如上图b所示
         *      可以用第二个文件来保存有序的块,假设外部存储的容量不成问题。通常希望避免改变初始文
         * 件的内容。
         *  - 归并
         *      第二步,要合并有序的块。第一趟中把每两块合并成一个含有两块的序列。因此,两个块
         * 2-9-11-14和4-12-13-16要合并成2-4-9-11-12-13-14-16。同样,3-5-10-15和1-6-7-8合并成
         * 1-3-5-6-7-8-10-15。结果如c所示。用第三个文件来保存这步合并的结果。
         *      第二趟,两个8条记录的序列合并成16条记录的序列,可以把它写回到第二个文件里,如图
         * d所示。现在排序就完成了。当然,要排序更大的文件时需要合并更多的步数:步数和log2N
         * 成正比。归并的步骤可以在两个文件中交替存储。
         *
         * 内部数组
         *      因为计算机内存中只能存放三个数据块,合并过程必须按一定的步骤来进行。设有三个数组,
         * 称为arr1、arr2和arr3,每个可以存储一个数据块
         *      第一次归并时,块2-9-11-14读入到arr1,4-12-13-16读入到arr2。这两个数组归并排序到arr3
         * 但是,因为arr3只能盛下一块,在排序完成前它就满了。当它满了以后,它的内容就写回到磁盘中
         * 去。然后排序就继续,再次填满arr3。这就完成了排序,arr3再次写回到磁盘中。下面的清单就是
         * 三次归并排序中每次的细节
         *  - 第一次归并
         *      1.将2-9-11-14读入到arr1中
         *      2.将4-12-13-16读入到arr2中。
         *      3.把归并结果2,4,9,11写入arr3;写回磁盘
         *      4.把归并结果12,13,14,16写入arr3;写回磁盘
         *  - 第二次归并
         *      1.将3-5-10-15读入到arr1中
         *      2.将1-6-7-8读入到arr2中。
         *      3.把归并结果1,3,5,6写入arr3;写回磁盘
         *      4.把归并结果7,8,10,15写入arr3;写回磁盘。
         *  - 第三次归并
         *      1.将2-4-9-11读入到arr1中。
         *      2.将1-3-5-6读入到arr2中。
         *      3.把归并结果1,2,3,4写入arr3:写回磁盘
         *      4.把5,6合并到arr3(arr2现在空了)
         *      5.把7-8-10-15读入到arr2中。
         *      6.把7,8合并到arr3中,写回磁盘。
         *      7.把9,10,11合并到arr3,(arr1现在空了)。
         *      8.把12-13-14-16读取到arr1中。
         *      9.把12合并到arr3中:写回磁盘。
         *      10.把13,14,15,16合并到arr3中,写入磁盘
         *      这10步最后的序列相当长,因此在每步完成时检查数组中的内容是很有帮助的。
         */

    }

    public static void testTree234() {
        long value;
        Tree234 theTree = new Tree234();

        theTree.insert(50);
        theTree.insert(40);
        theTree.insert(60);
        theTree.insert(30);
        theTree.insert(70);

        theTree.displayTree();
        theTree.insert(10);
        theTree.displayTree();
        theTree.insert(20);
        theTree.displayTree();
        theTree.insert(30);
        theTree.displayTree();
        theTree.insert(40);
        theTree.displayTree();
        theTree.insert(100);
        theTree.displayTree();
        theTree.insert(55);
        theTree.displayTree();
        theTree.insert(25);
        theTree.displayTree();

        int found = theTree.find(30);
        if(found != -1)
            System.out.println("Found 30");
        else
            System.out.println("Could not find 30");

        found = theTree.find(66);
        if(found != -1)
            System.out.println("Found 66");
        else
            System.out.println("Could not find 66");
    }  // end main()
    //--------------------------------------------------------------

//-------------------------------------------------------------
}
