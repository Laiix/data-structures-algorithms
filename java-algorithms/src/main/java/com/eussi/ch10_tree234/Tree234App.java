package com.eussi.ch10_tree234;

import com.eussi.ch10_tree234.util.Tree234;

/**
 * @author wangxueming
 * @create 2020-02-22 19:38
 * @description
 */
public class Tree234App {
    /**
     *      在二叉树中,每个节点有一个数据项,最多有两个子节点。如果允许每个节点可以有更多的数据项
     * 和更多的子节点,就是多叉树( multiway tree)。本章第一部分将要介绍的2-3-4树,就是多叉树,它的
     * 每个节点最多有四个子节点和三个数据项
     *      因为几个原因,2-3-4树非常有趣。首先,它像红-黑树一样是平衡树。它的效率比红-黑树稍差,
     * 但编程容易。其次,更重要的是,通过学习2-3-4树可以更容易地理解B树。
     *      B-树是另一种多叉树,专门用在外部存储中来组织数据(外部的意思是主存储的外部;通常是
     * 指磁盘驱动器)。B树中的节点可以有几十或几百个子节点。本章结尾部分会讨论外部存储和B-树
     * 2-3-4树的介绍
     */

    public static void main(String[] args) {
        /**
         * 2-3-4树的介绍
         *      下面将介绍2-3-4树的特征。本章还会介绍2-3-4树和红-黑树的惊人的相似性。
         *      下图展示了一棵小2-3-4树。每个节点可以保存一个、两个或三个数据项。
         *                                   |50| | |
         *                   /                                   \
         *              |30| | |                             |60|70|80|
         *           /        \              /           /           \                 \
         *     |10|20| |   |40| | |       |55| | |    |62|64|66|      |75| | |      |83|86| |
         *      图中上面的三个节点有子节点,底层的六个节点都是叶节点,没有子节点2-3-4树中所有的
         * 叶节点总是在同一层上。
         *
         * 名字的含义?
         *      2-3-4树名字中的2、3和4的含义是指一个节点可能含有的子节点的个数。对非叶节点有三种
         * 可能的情况
         *       - 有一个数据项的节点总是有两个子节点。
         *       - 有两个数据项的节点总是有三个子节点。
         *       - 有三个数据项的节点总是有四个子节点
         *      简而言之,非叶节点的子节点数总是比它含有的数据项多1。或者,用符号表示这个规则,设
         * 子节点链接的个数是L,数据项的个数是D,那么
         *      L=D+1
         *      这个重要的关系决定了2-3-4树的结构。比较来说,叶节点没有子节点,然而它可能含有一个、
         * 两个或三个数据项。空节点是不会存在的。
         *      因为2-3-4树最多可以有四个子节点的节点,也可以称它为4叉树。
         *      为什么不称2-3-4树为1-2-3-4树呢?它的节点不能像二叉树中那样只有一个子节点吗?因为二
         * 叉树的每个节点最多有两个子节点,所以二叉树(第8章“二叉树”和第9章“红-黑树”讲过的)
         * 可以称为二叉的多叉树。但是,二叉树和2-3-4树有一点不同(除了节点的最大子节点个数之外)
         * 二叉树中,节点最多有两个子节点的链接。它当然可以只有一个链接,指向它的左子节点或右子
         * 节点。它的另一个链接可以是null值。然而,在2-3-4树中,不允许只有一个链接。有一个数据项
         * 的节点必须总是保持有两个链接,除非它是叶节点,在那种情况下没有链接
         *      如图所示。有两个链接的节点称为2-节点,有三个链接的称为3-节点,有四个链接的称
         * 为4-节点,但没有称为1-节点的节点。
         *                  /
         *             |25| | |                             <-- 2-节点
         *           /        \
         *     |12| | |    |33|37| |
         *
         *                         /
         *                   |40|62| |                      <-- 3-节点
         *           /         \           \
         *     |27|33| |   |51|55|59|  |83| | |
         *
         *                              /
         *                         |50|75|95|                <-- 4-节点
         *           /          /          \           \
         *     |30|35| |   |55| | |  |78| | |     |100|105| |
         *
         * 2-3-4树的组织
         *      为了方便起见,用从0到2的数字给数据项编号,用0到3给子节点链编号。节点中的数据项按关键
         * 字值升序排列,习惯上从左到右升序(小数到大数)。
         *      树结构中很重要一点就是它的链与自己数据项的关键字值之间的关系。二叉树中,所有关键字
         * 值比某个节点值小的节点都在这个节点左子节点为根的子树上,所有关键字值比某个节点值大的节
         * 点都在这个节点右子节点为根的子树上。2-3-4树中规则是一样的,还加上了以下几点
         *       - 根是 child0的子树的所有子节点的关键字值小于key0。
         *       - 根是 child1的子树的所有子节点的关键字值大于key0并且小于key1
         *       - 根是 child2的子树的所有子节点的关键字值大于key1并且小于key2
         *       - 根是 child3的子树所有子节点的关键字值大于key2。
         *      2-3-4树中一般不允许出现重复关键字值,所以不用考虑比较相同的
         * 小的节点A、B间的节点B、C间的节点C大的节点
         *      所有的2-3-4树中,叶节点都在同一层(最底层)。上面层的节点一般都不满:也就是说,它们可能
         * 只含有一个或两个数据项,而不是三个。
         *      同样,注意树是平衡的。即使插入一列升序(或降序)排列的数据2-3-4树都能保持平衡。2-3-4
         * 树的自我平衡能力取决于新节点的插入方式,后面将会看到。
         *
         * 搜索2-3-4树
         *      查找特定关键字值的数据项和在二叉树中的搜索例程相类似。从根开始,除非查找的关键字值
         * 就是根,否则选择关键字值所在的合适范围,转向那个方向,直到找到为止
         *
         * 插入
         *      新的数据项总是插在叶节点里,在树的最底层。如果插入到有子节点的节点里,子节点的编号
         * 就要发生变化以此来保持树的结构,这保证了节点的子节点比数据项多1
         *      2-3-4树中插入节点有时比较简单,有时相当复杂。无论哪一种情况都是从查找适当的叶节点
         * 开始的
         *      査找时没有碰到满节点时,插入很简单。找到合适的叶节点后,只要把新数据项插入进去就可
         * 以了。
         *      插入可能会涉及到在一个节点中移动一个或者两个其他的数据项,这样在新数据项插入后关键
         * 值仍保持正确的顺序。
         *
         * 节点分裂
         *      如果往下寻找要插入位置的路途中,节点己经满了,插入就变得复杂了。发生这种情况时,节
         * 点必须分裂(split)。正是这种分裂过程保证了树的平衡。这里讨论的2-3-4树的是一种称为自顶向
         * 下的(top-down)2-3-4树,因为是在向下找到插入点的路途中节点发生分裂
         *      把要分裂节点中的数据项设为A、B和C。下面是分裂时的情况。(假设正在分裂的节点不是根
         * 后面会讲解根的分裂方法。)
         *       - 创建一个新的空节点。它是要分裂节点的兄弟,在要分裂节点的右边。
         *       - 数据项C移到新节点中。
         *       - 数据项B移到要分裂节点的父节点中。
         *       - 数据项A保留在原来的位置上。
         *       - 最右边的两个子节点从要分裂节点处断开,连到新节点上
         *      下图中显示的是一个节点分裂的例子。另一种描述节点分裂的方法是说4-节点变成两个2
         * 节点。
         *                                   |62| | |
         *                   /                                   \
         *              |29| | |                              |83|92|104| (|A|B|C|)
         *           /        \              /             /           \                \
         *     |15|21| |   |47| | |       |74| | |    |87|89| |      |97| | |      |112| | |
         *
         *                                  插入99后：
         *
         *                                   |62|92| |   <-- B
         *                   /                   \                         \
         *              |29| | |               |83| | |  <-- A          |104| | |  <-- C
         *           /        \                /     \               /           \
         *     |15|21| |   |47| | |       |74| | |  |87|89| |     |97|99| |      |112| | |
         *
         *      注意节点分裂是把数据向上和向右移动。正是这样的重新排列才可以保持树的平衡。
         *      插入只霱要分裂一个节点,除非插入路径上存在不止一个满的节点。这种情况就需要多重分
         * 裂。
         *
         * 根的分裂
         *      如果一开始查找插入点时就碰到满的根时,插入过程更复杂一点。类似于上面介绍的节点分裂，只不过需要在上面加一层根。
         *       - 创建新的根。它是要分裂节点的父节点。
         *       - 创建第二个新的节点。它是要分裂节点的兄弟节点。
         *       - 数据项C移到新的兄弟节点中
         *       - 数据项B移到新的根节点中
         *       - 数据项A保留在原来的位置上
         *       - 要分裂节点最右边的两个子节点断开连接,连到新的兄弟节点中
         *      以上过程中创建新的根,比旧的高一层。因此,整个树的高度就增加了1。另一种描述根分裂的方法是说4-节点变成三个2-节点。
         *      然后，顺着分裂的节点,继续向下查找插入点。
         *
         * 在下行路途中分裂
         *      注意,因为所有满的节点都是在下行路途中分裂的,分裂不可能向回波及到树上面的节点。任
         * 何要分裂节点的父节点肯定不是满的,因此该节点不需要分裂就可以插入数据项B。当然,如果父
         * 节点的子节点分裂时它已经有两个子节点了,它就变满了。但是,这只是意味着下次查找碰到它时
         * 才需要分裂。
         */
        testTree234();

        /**
         * 2-3-4树和红黑树
         *      2-3-4树和红黑树(第9章讲的)看上去可能完全不同。但是,在某种意义上它们又是完全相
         * 同的。一个可以通过应用一些简单的规则变成另一个,而且使它们保持平衡的操作也是一样的。数
         * 学上称它们为同构的。
         *      可能在实际应用时不需要把2-3-4树转变成红-黑树,但这种结构的等价性可以更清楚地表明它
         * 们的操作,并可以用于分析它们的效率。
         *      在历史上,2-3-4树先被提出:后来红黑树由它发展而来
         *
         * 2-3-4树转变为红黑树
         *      应用三条规则可以把2-3-4树转化成红黑树(WXYZ分表代表一个节点的四棵子树）
         *       - 把2-3-4树中的每个2-节点转化成红黑树的黑色节点
         *       - 把每个3-节点转化成一个子节点和一个父节点。子节点有两个自己的
         * 子节点:W和Ⅹ或Ⅹ和Y。父节点有另一个子节点:Y或W。哪个节点变成子节点或父
         * 节点都无所谓。子节点涂成红色,父节点涂成黑色。
         *       - 把每个4-节点转化成一个父节点和两个子节点。第一个子节点有它自
         * 己的子节点W和X;第二个子节点拥有子节点Y和Z。和前面一样,子节点涂成红色,
         * 父节点涂成黑色。
         *      下图展示了一棵2-3-4树和应用这些规则转化后对应的红黑树。转化后自动符合红黑树的规则。
         * 可以检验一下:两个红节点不会相连,每条从根到叶节点(或空子节点)的路径上黑节点的个数都是一样的
         *                                      |37| | |
         *                       /                                   \
         *                  |30|34| |                              |48|60|62|
         *           /        \        \              /             /          \           \
         *     |5| | |   |32|33| |   |35| | |      |40| | |    |50|53|57|   |69| | |    |86|98| |
         *
         *                         2-3-4树 <--> 红-黑树
         *
         *                           37(black)
         *                  /                     \
         *             34(black)                 60(black)
         *           /           \          /                 \
         *         30(red)    35(black)   48(red)            82(red)
         *      /      \                 /      \           /      \
         *  5(black) 32(black)    40(black)  53(black)  69(black) 96(black)
         *               \                    /      \            /
         *            33(red)              50(red) 57(red)    86(red)
         *      注意上面的2-节点，可以有两种形式的转换，都可以。
         *      可以说,2-3-4树中的3-节点等价于红黑树中有一个红色子节点的父节点,4-节点等价于有两
         * 个红色子节点的父节点。红-黑树中有一个黑色子节点的黑色节点不对应2-3-4树中的3-节点:它只
         * 表示有另一个2-节点子节点的2-节点。同样,有两个黑色子节点的黑色父节点也不代表4-节点。
         *
         * 操作的等价性
         *      不仅红-黑树的结构与2-3-4树对应,而且两种树的操作也是一样的。2-3-4树中用节点分裂保
         * 持平衡。红黑树中两种保持平衡的方法是颜色交换和旋转
         *  - 4-节点分裂和颜色变换
         *      在2-3-4树中向下为一个新节点寻找插入点时,把每个4节点分裂成两个2节点。红黑树中利
         * 用颜色变换。这两个操作怎么是等价的呢?
         *      下图中是2-3-4树中的一个4-节点在分裂前的样子。4-节点的父节点2-节点变成了3-节点。
         *
         *                     /                4-节点分裂                 /
         *                |70| | |                                    |50|70| |
         *              /        \                               /    B  \        \
         *        |40|50|60|    |80| | |                   |40| | |   |60| | |    |80| | |
         *        /A /B\ C \                               /A\        /C\
         *      下图中展示了与上图中的2-3-4树等价的红黑树。
         *      颜色变化后得到如下图所示的红黑树。现在节点40和60是黑色的,节点50是红色的。因此
         * 节点50和它的父节点对应于3-节点。这和上图中通过节点分裂得到的3-节点是一样的。
         *                      /                                    /
         *                   70(black)                            70(black)
         *                /            \                       /            \
         *         50(black)        80(black)             50(red)        80(black)
         *          /      \                             /      \
         *     40(red)   60(red)                    40(black)   60(black)
         *      因此,在2-3-4树的插入过程中分裂4-节点与红黑树的插入过程中的颜色变换是等价的。
         *  - 3-节点分裂和旋转
         *      2-3-4树中的3节点要转化成等价的红-黑树中的节点时,有两种可能的排列方式,如前面所述。两个数据
         * 项中的任何一个都可以成为父节点。选定一个做父节点后,子节点可以是左子节点或者是右子节点,就是说连接
         * 父节点和子节点的斜线可以向左斜或向右斜。
         *      这两种排列都是允许的:但是它们对保持树的平衡来说作用可能不一样。在稍大的范围内来讨
         * 论这个问题
         *      下图中是一棵2-3-4树,应用转换规则从2-3-4树得到的等价红黑树。它们之间的不同是选择3-节点的两个
         * 数据项中的哪个来做父节点。
         *                                           /
         *                                      |70|80| |
         *                                /        \          \
         *                          |40|50|60|    |75| | |   |80| | |
         *                          / / \ \       / \        / \
         *
         *              左倾                       /
         *                                      80(black)
         *                                   /            \
         *                              70(red)        85(black)
         *                           /          \
         *                     50(black)        75(black)
         *                      /      \        /    \
         *                 40(red)   60(red)
         *
         *              右倾                       /
         *                                      70(black)
         *                                   /            \
         *                            50(black)           80(red)
         *                           /        \          /       \
         *                    40(red)      60(red)  40(black)   60(black)
         *                    /    \       /    \     /   \       /   \
         *      虽然这些排列方法都是允许的,但可以看到左倾的树是不平衡的,右倾中则是平衡的。对左倾
         * 中的红黑树,可以向右旋转(并进行颜色变幻)来保持平衡。令人惊异的是,旋转得到的树和c)
         * 中的树是一样的。
         *      因此,红-黑树中的旋转和把2-3-4树转换成红-黑树时选择哪个节点做父节点是等价的。虽然
         * 没有提及,但对子孙节点中需要进行两次旋转时,也是等价的。
         *
         * 2-3-4树的效率
         *      分析23-4树的效率比红黑树要困难,但还是可以从两者的等价性开始分析。
         *
         * 速度
         *      如第8章所示,查找过程中红黑树每层都要访问一个节点,可能是查找已经存在的节点,也
         * 可能是插入一个新节点。红黑树的层数(平衡二叉树)大约是log2(N+1),所以搜索时间与层数成
         * 比例
         *      2-3-4树中同样要访问每层的一个节点,但2-3-4树比有相同数据项的红黑树短(层数少)。参
         * 考上图可以看得出。
         *      更特别的是,2-3-4树中每个节点最多可以有4个子节点。如果每个节点都是满的,树的高
         * 度应该和log4(N)成正比。以2为底的对数和以4为底的对数底数相差2。因此,在所有节点都满
         * 的情况下,2-3-4树的高度大致是红-黑树的一半。不过它们不可能都是满的,2-3-4树的高度就
         * 大致在log2(N+1)和log2(N+1)2之间。减少2-3-4树的高度可以使它的查找时间比红黑树的短
         * 一些。
         *      另一方面,每个节点要查看的数据项就更多了,这会增加查找时间。因为节点中用线性搜索来
         * 查看数据项,使查找时间增加的倍数和M成正比,即每个节点数据项的平均数量。总的查找时间和
         * M*log4(N)成正比。
         *      有些节点有一个数据项,有些有两个,有些有三个。如果按平均两个来计算,查找时间和2*Log4(N)
         * 成正比。在大O表示法中这个小的常数可以忽略。
         *      因此,2-3-4树中增加每个节点的数据项数量可以抵偿树的高度的减少。2-3-4树中的查找时间
         * 与平衡二叉树如红黑树大致相等,都是O(logN)。
         *
         * 存储需求
         *      2-3-4树中每个节点保存三个数据项的引用和四个子节点的引用。这些空间可以用数组的形式
         * ,或者用单独的变量。这些存储空间不是都有用的。只有一个数据项的节点会
         * 浪费2/3的数据项存储空间和1/2的子节点的存储空间。两个数据项的节点就浪费了1/3的数据项存
         * 储空间和1/4的子节点存储空间;换一种说法,它只利用了5/7的可用空间
         *      平均按每个节点有两个数据项来计算,大约有2/7的存储空间浪费了
         *      可能会想到用链表来代替数组以保存子节点和数据的引用。但对只有三个或四个数据项来说
         * 链表的额外开销和数组比起来,用链表也许并不是一个值得用的方法
         *      因为红黑树是平衡的,所以没有几个节点只有一个子节点,因此几乎所有子节点引用的存储
         * 空间都利用了。同样,每个节点都保存了一个数据项的最大项数值。这使红黑树在存储上比2-3-4
         * 树利用率更高。
         *      Java中,存储对象的引用而不是对象本身,在2-3-4树和红黑树之间这个存储差异并不重要
         * 而且对2-3-4树编程当然更容易些。但是,在不是用保存引用这种方法的编程语言中,2-3-4树和红
         * 黑树间存储的效率差异可能就很显著了
         *
         * 2-3树
         *      下面将简单地讨论一下2-3树,因为在历史上它很重要,并且在很多应用程序中还在应用。同
         * 时,一些用于2-3树的技术会在B-树中应用，下面将要学习到B-树。最后,因为仅仅修改了每个
         * 节点的子节点数目就会使树的算法有很大的变化,这个问题很有趣。
         *      2-3树和234树类似,除了从名字中就可以猜到的不同之处,2-3树的节点比2-3-4树少存
         * 个数据项和少一个子节点。2-3树是第一种多叉树,由 J.E.Hopcroft在1970年发明。B-树(2-3-4树
         * 是它的特例)直到1972年才发明。
         *      2-3树的操作在很多方面都和2-3-4树类似。节点可以保存1个或2个数据项,可以有0个,1
         * 个、2个或3个子节点。其他的方面,父节点和子节点的关键字值的排列顺序是和2-3-4树一样的
         * 向节点插入数据项简单一些,因为需要的比较和移动次数少了。和2-3-4树中一样,所有新数据项
         * 都插入到叶节点中去,而且所有的叶节点都在树的最底层
         *
         * 节点分裂
         *      查找一个存在的数据项的方法和2-3-4树一样,只是数据项和子节点的数量不一样。可能会认
         * 为插入过程也和2-3-4树类似,但分裂节点的过程有很大的不同。
         *      下面来看为什么分裂过程那么不同。在这两种树中,无论哪一种树节点进行分裂都需要三个数
         * 据项:一个保留在要分裂的节点里,一个右移到新的节点里,还有一个要上移到父节点里。2-3-4
         * 树中一个满的节点有三个数据项,它们都各自移到自己的位置中去。但是,在2-3树中满的节点只
         * 有两个数据项,到哪里去找第三个数据项呢?因此必须要用到新的数据项:即要插入到树中的数据
         * 项
         *      2-3-4树中在所有分裂完成之后才插入新数据项。2-3树中新的数据项必须参与分裂过程。它必
         * 须要插入到叶节点中去,这就不可能在下行路途中进行分裂。如果新数据项要插入的叶节点不满,
         * 新数据项可以立即插入进去,如果叶节点满了,该节点就得分裂。该节点的两个数据项和新数据项
         * 分在这三个节点里:已存在的节点、新节点和父节点。如果父节点不是满的,操作就完成了(在连
         * 接新节点之后)。如下图所示：
         *             |75| |                       |75|85|
         *           /       \                  /       \       \
         *     |70|80|     |80|90|        |70| |     |80| |    |90| |
         *      但是,如果父节点是满的,父节点也必须要分裂。它的两个数据项和自己分裂的子节点传上来
         * 的数据项必须分配到父节点,父节点的新的兄弟节点,以及父节点的父节点中去。这种情况如图1018
         * 所示。
         *      如果父节点的父节点(叶节点的祖父节点)是满的,还是要分裂。分裂过程向上延续直到找到
         * 不满的父节点或者遇到根。如果根也是满的,就要创建一个新的根作为原来的根的父节点,如下图：
         *             |50| |                                      |50|85|
         *           /       \                         /            \             \
         *                |80|90|                                |75| |          |95| |
         *            /       \      \                          /     \        /        \
         *        |70| |   |80| |   |90|95|                |70| |   |80| |   |90| |   |100| |
         *
         * 实现
         *      Java完整地实现2-3树留作练习，见excise。但是,最后还是来提示一下如何处理分裂地过程
         * 这只有一个方法(还有一种方法允许每个节点保存一个假的第四个子节点)
         *      向下插入过程的例程不理会遇到的节点是满还是不满。它顺着树向下查找直到找到要插入的叶
         * 节点。如果叶节点不满,就插入新的值。但是,如果叶节点满了,需要重新整理树来挪出位置。要
         * 做这件事,需要调用 split方法。传入这个方法的参数是满了的叶节点和新的数据项。它会负责分
         * 裂这个节点并把新节点插入到新的叶节点里
         *      如果 split方法发现叶节点的父节点也是满的,它递归调用自己来分裂父节点。 split方法一直
         * 调用自身,直到找到不满的叶节点或找到根为止。split的返回值是新的右节点,它可以被前面调
         * 的 split方法应用
         *      由于几个因素,编写分裂过程的代码是很复杂的。首先,2-3-4树中三个要分开的数据项是已
         * 经有序的,但2-3树中新数据项的关键字值必须和其他两个叶节点中的数据项比较;然后根据比较
         * 结果分配这三个数据项。
         *      另外,分裂父节点会创建第二个父节点,所以现在有一个左父节点(原来的)和一个新的右父
         * 节点。需要把连到一个父节点上的三个子节点的连接,变成两个父节点每个有两个子节点的状态
         * 这里有三种情况,取决于哪个子节点(0,1或2)要分裂。如下图(d表示删除，n表示新建)：
         *      插入45，分裂child0:
         *                |60|80|                                         |60| |
         *            /       \d      \d                            /n            \n
         *        |40|50|   |70| |   |90| |                     |45| |          |80| |
         *                                                     /     \n       /n       \n
         *                                                |40| |   |50| |   |70| |   |90| |
         *
         *      插入73，分裂child1:
         *                |60|80|                                        |73| |
         *            /       \      \d                             /n              n
         *        |40| |   |70|75|   |90| |                     |60| |          |80| |
         *                                                     /     \        /n       \n
         *                                                |40| |   |70| |   |75| |   |90| |
         *
         *      插入93，分裂child2:
         *                |60|80|                                        |80| |
         *            /       \      \d                             /n             \n
         *        |40| |   |70| |   |90|95|                     |60| |          |93| |
         *                                                     /     \        /n       \n
         *                                                |40| |   |70| |   |90| |   |95| |
         */

    }

    public static void testTree234() {
        long value;
        Tree234 theTree = new Tree234();

        theTree.insert(50);
        theTree.insert(40);
        theTree.insert(60);
        theTree.insert(30);
        theTree.insert(70);

        theTree.displayTree();
        theTree.insert(10);
        theTree.displayTree();
        theTree.insert(20);
        theTree.displayTree();
        theTree.insert(30);
        theTree.displayTree();
        theTree.insert(40);
        theTree.displayTree();
        theTree.insert(100);
        theTree.displayTree();
        theTree.insert(55);
        theTree.displayTree();
        theTree.insert(25);
        theTree.displayTree();

        int found = theTree.find(30);
        if(found != -1)
            System.out.println("Found 30");
        else
            System.out.println("Could not find 30");

        found = theTree.find(66);
        if(found != -1)
            System.out.println("Found 66");
        else
            System.out.println("Could not find 66");
    }  // end main()
    //--------------------------------------------------------------

//-------------------------------------------------------------
}
