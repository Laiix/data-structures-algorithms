package com.eussi.chapter03;

import com.eussi.chapter03.helper.ArrayBub;
import com.eussi.chapter03.helper.ArraySel;

/**
 * @author wangxueming
 * @create 2019-10-21 16:46
 * @description
 */
public class Sort {

    /**
     * 计算机程序不能像人这样通览所有的数据。它只能根据计算机的“比较”操作原理,在同一
     * 时间内对两个队员进行比较。
     * 算法的这种“管视(狭隘的见识)”将是一个反复出现的问题。在人类看来很简单的
     * 事情,计算机的算法却不能看到全景,因此它只能一步一步地解决具体问题和遵循一些简单的规则
     * <p>
     * 本章中三个算法都包括如下的两个步骤,这两步循环执行,直到全部数据有序为止
     * 1.比较两个数据项
     * 2.交换两个数据项,或复制其中一项。
     * 但是,每种算法具体实现的细节有所不同
     */

    public static void main(String[] args) {
        /**
         * 冒泡排序
         *      冒泡排序算法运行起来非常慢,但在概念上它是排序算法中最简单的,因此冒泡排序算法在刚
         * 开始研究排序技术时是一个非常好的算法。
         *      冒泡算法名称的由来主要是因为在执行算法的时候，最大的数据项总是“冒泡”到数组的顶端。
         */
        testBubbleSort();
        /**
         *      这个算法的思路是要将最小的数据项放在数组的最开始(数组下标为0),并将最大的数据项放
         * 在数组的最后(数组下标为 nelms-1)。外层for循环的计数器out从数组的最后开始,即out等于
         * nelms-1,每经过一次循环out减一。下标大于out的数据项都已经是排好序的了。变量out在每完
         * 成一次内部循环(计数器为in)后就左移一位,因此算法就不再处理那些已经排好序的数据了。
         *      内层for循环计数器in从数组的最开始算起,即in=0,每完成一次内部循环体加一,当它等于
         * out时结束一次循环。在内层for循环体中,数组下标为in和in+1的两个数据项进行比较,如果下
         * 标为in的数据项大于下标为in+1的数据项,则交换两个数据项。
         *      为了清晰起见,使用了一个独立的swap(方法来执行交换操作。它只是交换数组中的两个数据
         * 项的值,使用一个临时变量来存储第一个数据项的值,然后把第二项的值赋给第一项,之后让第二
         * 项的值等于临时变量的值。实际上,使用一个独立的 swap()方法不一定好,因为方法调用会增加
         * 些额外的消耗。如果写自己使用的排序程序,最好将交换操作这段代码直接放到程序中,这样可以
         * 提高一些速度。
         *
         * 不变性
         *      在许多算法中,有些条件在算法执行时是不变的。这些条件被称为不变性。认识不变性对理解
         * 算法是有用的。在一定的情况下它们对调试也有用;可以反复地检查不变性是否为真,如果不是的
         * 话就标记出错
         *      在 冒泡排序程序中,不变性是指out右边的所有数据项为有序。在算法的整个运行过程
         * 中这个条件始终为真。(在第一趟排序开始前,尚未排序,因为out开始时在数据项的最右边,没有
         * 数据项在out的右边。)
         *
         * 冒泡排序效率：
         *      一般来说,数组中有N个数据项,则第一趟排序中有N-1次比较,第二趟中有N-2次,如此
         * 类推。这种序列的求和公式如下
         * (N-1)+(N-2)+(N-3)+...+2+1=N*(N-1)/2
         *      这样,算法作了约N²/2次比较(忽略减1,不会有很大差别,特别是当N很大时)
         * 因为两个数据只有在需要时才交换,所以交换的次数少于比较的次数。如果数据是随机的,那
         * 么大概有一半数据需要交换,则交换的次数为N/4。(不过在最坏的情况下,即初始数据逆序时,
         * 每次比较都需要交换。)
         *      交换和比较操作次数都和N²成正比。由于常数不算在大O表示法中,可以忽略2和4,并且认
         * 为冒泡排序运行需要O(N²)时间级别。
         *      无论何时,只要看到一个循环嵌套在另一个循环里,例如在冒泡排序和本章中的其他排序算法
         * 中,就可以怀疑这个算法的运行时间为O(N²)级。外层循环执行N次,内部循环对于每一次外层循
         * 环都执行N次(或者几分之N次)。这就意味着将大约需要执行N*N或者N²次某个基本操作
         */


        /**
         * 选择排序
         *      选择排序改进了冒泡排序,将必要的交换次数从O(N²)减少到O(N)。不幸的是比较次数仍保持
         * 为O(N²)。然而,选择排序仍然为大记录量的排序提出了一个非常重要的改进,因为这些大量的记
         * 录需要在内存中移动,这就使交换的时间和比较的时间相比起来,交换的时间更为重要。(一般来
         * 说,在Java语言中不是这种情况,Java中只是改变了引用位置,而实际对象的位置并没有发生改变。)
         *      进行选择排序就是把所有的数据扫描一趟,从中挑出(或者说选择,这正是这个排序名字的由
         * 来)最小的一个数据。最小的这个数据和最左端的数据交换位置,即站到0号位置。现在
         * 最左端的数据是有序的了,不需要再交换位置了。注意,在这个算法中有序的数据都排列在队列的
         * 左边(较小的下标值),而在冒泡排序中则是排列在队列右边的。
         */
        testSelSort();
        /**
         * 算法描述：
         *      外层循环用循环变量out,从数组开头开始(数组下标为0)向高位增长。内层循环用循环变量
         * in,从out所指位置开始,同样是向右移位。
         *      在每一个in的新位置,数据项a[in]和a[min]进行比较。如果a[in]更小,则min被赋值为in的
         * 值。在内层循环的最后,min指向最小的数据项,然后交换out和min指向的数组数据项。
         *
         * 不变性
         *      在 选择排序程序中,下标小于或等于out的位置的数据项总是有序的。
         *
         * 选择排序的效率
         *      选择排序和冒泡排序执行了相同次数的比较:N(N-1)2。对于10个数据项,需要45次比较。
         * 然而,10个数据项只需要少于10次交换。对于100个数据项,需要4950次比较,但只进行了不到
         * 100次的交换。N值很大时,比较的次数是主要的,所以结论是选择排序和冒泡排序一样运行了O
         * (N2)时间。但是,选择排序无疑更快,因为它进行的交换少得多。当N值较小时,特别是如果交
         * 换的时间级比比较的时间级大得多时,选择排序实际上是相当快的
         */


    }

    private static void testSelSort() {
        int maxSize = 100;            // array size
        ArraySel arr;                 // reference to array
        arr = new ArraySel(maxSize);  // create the array

        arr.insert(77);               // insert 10 items
        arr.insert(99);
        arr.insert(44);
        arr.insert(55);
        arr.insert(22);
        arr.insert(88);
        arr.insert(11);
        arr.insert(00);
        arr.insert(66);
        arr.insert(33);

        arr.display();                // display items

        arr.selectionSort();          // selection-sort them

        arr.display();                // display them again
    }

    private static void testBubbleSort() {
        int maxSize = 100;            // array size
        ArrayBub arr;                 // reference to array
        arr = new ArrayBub(maxSize);  // create the array

        arr.insert(77);               // insert 10 items
        arr.insert(99);
        arr.insert(44);
        arr.insert(55);
        arr.insert(22);
        arr.insert(88);
        arr.insert(11);
        arr.insert(00);
        arr.insert(66);
        arr.insert(33);

        arr.display();                // display items

        arr.bubbleSort();             // bubble sort them

        arr.display();                // display them again
    }
}
