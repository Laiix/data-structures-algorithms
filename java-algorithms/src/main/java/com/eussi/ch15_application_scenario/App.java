package com.eussi.ch15_application_scenario;

/**
 * @author wangxueming
 * @create 2020-03-13 21:14
 * @description
 */
public class App {
    /**
     * 应用场景
     *      本章简要地总结了到目前为止所学的知识，并着眼于讨论在不同的情况如何决定使用哪种
     * 数据结构和算法。
     *      本章还有必要提醒读者，每一个真实世界的问题都有各自的特性，因此我们在这里所说的
     * 并不一定就是你所遇问题的正确答案，这种情况是经常出现的。下面把本章的内容大致分一下组：
     *      •通用数据结构：数组，链表，树，哈希表
     *      •专用数据结构：栈，队列，优先级队列
     *      •排序：插入排序，希尔排序，快速排序，归并排序，堆排序
     *      •图：邻接矩阵，邻接表
     *      •外部存储：顺序存储，索引文件，B-树，哈希方法
     *
     * 注释：
     *      想要了解这些主题的信息，请参阅前面章节
     */
    public static void main(String[] args) {
        /**
         * 通用数据结构
         *      若想存储真实世界中的类似人事记录、存货目录、合同表或销售业绩等数据，则只需要
         * 一般用途的数据结构。在本书中属于这种类型的结构有数组、链表、树和哈希表。它们被称之
         * 为通用的数据结构是因为它们通过关键字的值来存储并査找数据，这一点在通用数据库程序中
         * 常见到(栈等特殊结构正好相反，它们只允许存取一定的数据项)。
         *      对于一个给定问题，这些通用数据结构中哪一种是合适的呢？下图对这个问题给出了一
         * 个大致的解法。但是除去图中表示出来的因素之外，还有许多条件可以影响最终结果。为了更
         * 加详细地讨论这个问题，我们会先探讨一些通用的因素，然后再集中精力于个别的结构。
         *
         * ------------------------------------------------------------------------------
         *                               是                    不是
         *        开始   →    数据量小     →      数据量可预知     →     链表
         *
         *                       ↓不是               ↓是
         *
         *              是   查找和插入           查找速度是      是
         *     哈希表    ←   的速度必须           否比插入速       →     有序数组
         *                  很快吗?              度更重要?
         *
         *                      ↓不是                ↓不是
         *
         *              是   关键字分布            无序数组
         * 二叉查找树     ←   肯定是随机
         *                   的吗?
         *
         *                      ↓不是
         *
         *                    平衡数
         *-----------------------------------------------------------------------------------
         *
         * 速度与算法
         *      通用数据结构可以完全按照速度的快慢来分类：
         *      数组和链表是最慢的，树相对较快，哈希表是最快的。
         *      但是请不要从上图中得到这样的结论：使用最快的结构永远是最好的方案。这些最快的结
         * 构也有缺陷。首先，它们的程序在不同程度上比数组和链表的复杂；其次，哈希表要求预先知道
         * 要存储多少数据，数据对存储空间的利用率也不是非常高。普通的二叉树对顺序的数据来说，会
         * 变成缓慢的O(N)级操作；而平衡树里然避免了上述的问题，但是它的程序编制起来却比较困难。
         *
         * 处理器速度：一个变动着的目标
         *      快速的结构都有缺陷，而计算机的另一个发展因素却能使低速的结构更加具有吸引力。新计
         * 算机的CPU和存取速度每一年都有提升。Moore定律（Gordon Moore在1965年提出）声明了 CPU
         * 的速度每18个月翻一倍。这造成了早期计算机和现今应用的计算机在性能方面的惊人差异，而且目
         * 前没有任何理由能认为这个增长速度会减慢。
         *      假设几年前的一台电脑可以在一个可接受的时间内处理含有100个对象的数组，而现在的计
         * 算机则快多了，因此可以在同样的时间里处理含有10000个对象的数组。许多作者都对某种数据结
         * 构的最大可应用范围给出了定量的估计，超出了这个范围会变得很慢。请不要相信这些估计（包括
         * 本书在内）。今天的估计不能应用于明天。
         *      请从简单数据结构入手考虑：除非它们明显是太慢了，否则就用数组或链表编写程序，看看
         * 结果究竟怎样。如果能在一个可接受的时间内运行完毕，那么就采用它，不必再找别的了。没有人
         * 会留意用的是数组或别的什么结构，为什么一定要拼命地写出一个平衡树的算法？甚至必须面对成
         * 千上千万、百万的数据项进行操作时，不妨先看一看数组或链表处理表现的情况，这也还是值得的。
         * 只有在实验中发现这些简单结构的性能太慢时，才回过头来采用那些更加复杂的数据结构。
         *
         * Java引用的优点
         *      在操作对象的速度上，Java与其他语言相比有极大的优势，那是由于对于大多数数据结构来
         * 说， Java只存储引用（reference)而不是实际的对象，因此相对于那些在数据结构中实际为对象
         * 开辟了空间的语言来说，大多数Java算法的执行速度更快。在分析算法时，不是从对象的真实存储
         * 空间出发，因而“移动”对象的速度也不依赖于对象的大小，而只是考虑对象引用的移动，因此对象
         * 本身的大小就不重要了 •
         *      当然在类似C++等其他语言中，也可以存储对象的指针而不是存储对象本身，这与使用引用的
         * 效果是一样的，但是它们的语法更加复杂。
         *
         * 类库
         *      在所有主要的编程语言中，都具备商用数据结构库。在这些语言中有一些内罝的结构。比如在
         * Java中，有向量、栈和哈希表类：在C++中有标准模板库，其中含有许多数据结构和算法。
         *      使用一个商用类库可能会去掉或至少削减创建本书描述的数据结构的必要编程。当处于这种情
         * 况时，更加吸引人的是使用一个如平衡树这样的复杂结构或象快排这样的精巧算法。然而，采用时必
         * 须确保这个类真正能够适应你的特定的情况。
         *
         * 数组
         *      当存储和操作数据时，在大多数情况下数组是首先应该考虑的结构。数组在下列情况下很有用：
         *       • 数据量较小。
         *       • 数据量的大小事先可预测。
         *      如果存储空间足够大的话，可以放松第二条，创建一个足够大的数组来应付所有可以预见的数据
         * 输入。
         *      如果插入速度很重要的话.使用无序数组.如果査找速度很重要的话，使用有序数组，并用二分査
         * 找。数组元素的删除总是很慢，这是由于为了填充空出来的单元，平均半数以上的数组元素要被移动。
         * 在有序数组中的遍历（指按关键字的有序遍历——译者注）是很快的，而在无序的数组不支持这种功能。
         *      向量（如Java中的向量类）是一种当数据太满时可以自己扩充空间的数组。向量可以应用于数据
         * 量不可预知的情况下。然而，在向量扩充时，要将旧的数据拷入一个新的空间中，这一过程会造成程序
         * 明显的周期性暂停。
         *
         * 链表
         *      如果需要存储的数据量不能预知或者需要频繁地插入删除数据元素时，考虑使用链表。当有新的
         * 元素加入时。链表就开辟新的所需要的空间，所以它甚至可以占满全部可用内存：在刪除过程中没有必
         * 要像数组那样添补“空洞”。
         *      在一个无序的链表中，插入是相当快的。査找和删除却很慢(尽管比数组的删除快一些），因此，
         * 与数组一样，链表最好也应用于数据量相对较小的情况。
         *      对于编程而链表比数组复杂，但它比树或哈希表简单。
         *
         * 二叉搜索树
         *      当确认数组和链表过慢时，二叉树是最先应该考虑的结构，树可以提供快速的O(logN)级的插入、
         * 査找和删除。遍历的时间复杂度是O(N)级的，这是任何数据结构遍历的最大值（根据定义，必须访问所有
         * 的数据)。对于遍历一定范围内的数据可以很快得出访问数据的最大值和最小值。
         *      对于程序来说，不平衡的二叉树要比平衡二叉树简单得多，但不幸的是，有序数据能将它的性能降
         * 至O(N)级，不比一个链表好多少。然而如果可以保证数据是随机进入的，就不需要用平衡二叉树，
         *
         * 平衡树
         *      在众多平衡树中，我们讨论了红-黑树和2-3-4树，它们都是平衡树，并且无论输入数据是否有序，
         * 它们都能保证性能为O(logN)。然而对于编程来说，这些平衡树都是很有挑战性的，其中最难的是红-黑树。
         * 它们也因用了附加存储而产生额外耗费，这对系统或多或少有些影响。
         *      如果利用树的商用类可以降低编程的复杂性。有些情况下，选择哈希表比平衡树更好。即便当数据有
         * 序时，哈希表的性能也不降低。
         *      平衡树有许多种，其中包括AVL树、splay树、2-3树等，但它们不如红-黑树使用得广泛。
         *
         * 哈希表
         *      哈希表在数据存储结构中速度最快。这使它成为计算机而不是人与数据交互时的必需。哈希表通常用
         * 于拼写检査器和作为计算机语言编译器中的符号表，在这些应用中，程序必须在几分之一秒的时间里检査上
         * 千的词或符号。
         *      当人而不是计算机初始化操作数据的存储时，哈希表会很有用。正如前文所提到的，哈希表对数据插入
         * 的顺序并不敏感，因此可以取代平衡树。但是哈希表的编程却比平衡树简单多了。
         *      哈希表需要有额外的存储空间，尤其是对于开放地址法。因为哈希表用数组作为基本结构，所以，必须
         * 预先精确地知道待存储的数据量。
         *      用链地址法处理冲突的哈希表是最健壮的实现办法。若能预先精确地知道数据量，在这种情况下用开放
         * 地址法编程最简单，因为不需要用到链表类。
         *      哈希表并不能提供任何形式的有序遍历，或对最大最小值元素进行存取。如果这些功能重要的话，使用
         * 二叉搜索树更好一些。
         *
         * 通用数据存储结构的比较
         *      下表用大O表示法总结了不同的通用数据存储结构的速度。
         *          数据结构        查找      插入      删除      遍历
         *  ------------------------------------------------------------------
         *          数组            O(N)     O(1)      O(N)      ——
         *          有序数组        O(logN)  O(N)      O(N)      O(N)
         *          链表            O(N)     O(1)      O(N)      ——
         *          有序链表        O(N)     O(N)      O(N)      O(N)
         *          二叉树(一般情况) O(logN)  O(logN)   O(logN)   O(N)
         *          二叉树(最坏情况) O(N)     O(N)      O(N)      O(N)
         *    平衡树(一般和最坏情况) O(logN)  O(logN)   O(logN)   O(N)
         *          哈希表          O(1)     O(1)      O(1)      ——
         *  ------------------------------------------------------------------
         *      假设未经排序的数组的插入是在数组的后端进行的。有序数组在进行二分查找
         * 时很快，但是插入和删除却很慢，因为这些操作平均要移动一半的元素。遍历意味着
         * 通过升序或降序的关键字来对数据进行访问，——符号表示不支持这个操作。
         *  ------------------------------------------------------------------
         *
         * 专用数据结构
         *      本书中讨论的专用数据结构有栈、队和优先级队列。这些结构不是为了用户可访问的数据库而建立的，
         * 通常用它们在程序中辅助实现一些算法。我们在本书中见到了许多这样的例子，譬如在第 13章“图”和第14
         * 章“带权图”的图的算法中都用到栈、队和优先级队列。
         *      栈、队和优先级队列是抽象数据类型（ADT),它们又由一些更加基础的结构如数组、链表或堆（如在优
         * 先级队列中）组成。这些ADT只提供给用户简单的接口，一般仅允许插入和访问或者删除一个数据项。
         *      这些数据项是：
         *      对于栈：最后被插入的数据项
         *      对于队：最先被插入的数据项
         *      对于优先级队列：具有最高优先级的数据项
         *      这些ADT可以被当作帮助理解的概念。它们的功能可以通过直接使用基础结构(如数组)来实现，但是它
         * 们提供的精简的接口可以简化许多问题。
         *
         * 栈
         *      栈用在只对最后被插入数据项访问的时候.它是一个后进先出（LIFO)的结构。
         *      栈往往通过数组或链表实现，通过数组实现很有效率，因为最后被插入的数据总是在数组的最后，这个
         * 位置的数据很容易被删除，栈的溢出有可能出现，但当数组的大小被合理的规划后，溢出并不常见，因为栈很
         * 少会拥有大量的数据。
         *      如果栈拥有许多数据，并且数量不可精确预测（当用栈实现递归时）时，用链表比数组更好一些，这是
         * 由于从表头的位置删除或插入一个元索很方便。除非整个内存满了，栈的溢出不可能出现。链表比数组稍慢一
         * 些，因为对于插入一个新链接必须分配内存，从表中某链接点上删除元素后回收分配内存亦是必需的。
         *
         * 队
         *      队用在只对最先被插入数据项访问的时候，它是一个先进先出（FIFO)的结构。
         *      同栈相比，队同样可以通过数组和链表实现。这两种方法都很有效率。数组需要附加的程序来处理队在数
         * 组尾部回绕的情况。链表必须是双端的，这样才能从一端插入从另一端刪除。
         *      用数组还是链表来实现队的选择是通过数据量是否可以被很好地预测来决定的。如果知道会有多少数据量
         * 的话，就使用数组；否则的话就用链表。
         *
         * 优先级队列
         *      优先级队列用在只对访问最高优先级数据项访问的时候，最高优先级数据项就是含有最大(有时最小)的关
         * 键字的项。
         *      优先级队列可以用有序数组或堆来实现。向有序数组中插入是很慢的，但是删除很快。使用堆来实现优先
         * 级队列，插入和删除的时间复杂度都是O(logN)级，
         *      当插入速度不重要时，可以使用数组或双端链表。当数据量可以被预测时，使用数组：当数据量未知时，
         * 使用链表。如果速度很重要的话，选择堆更好一些。
         *
         * 专用结构的比较
         *      下表用大O表示法比较了栈、队和优先级队列。这些结构都不支持査找或遍历。
         *          数据结构                插入      删除      注释
         *  ------------------------------------------------------------------
         *          栈(数组和链表)          O(1)      O(1)      删除最后插入的
         *          队(数组和链表)          O(1)      O(1)      删除最先插入的
         *          优先级队列(有序数组)    O(N)      O(1)      删除优先级最高的
         *          优先级队列(堆)         O(logN)   O(logN)
         *  ------------------------------------------------------------------
         *
         * 排序
         *      当选择数据结构时.可以先尝试一种较慢但简单的排序，例如插入排序。如果采用了这些方法，现代计算
         * 机的快速处理速度也有可能在恰当的时间内将较大的数据量排序。（比较粗略的估计是， 较慢的排序对少于
         * 1000的数据量为宜。）
         *      插入排序对几乎己排好的文件也很有效，如果没有太多的元素处于乱序的位置上，操作的时间复杂度大约
         * 在O(N)级。这通常发生在往一个己排好序的文件中插入一些新的数据元素的情况。
         *      如果插入排序显得太慢，下一步可以尝试希尔样序。它很容易实现，并且使用起来不会因为条件不同而性
         * 能变化差距太大；Sedgewick估计它在数据量为5000以下时很有用。
         *      只有当希尔排序变得很慢时，你才应该使用那些更复杂但更快速的排序方法：归并排序、堆排序或快速排
         * 序。归并排序需要辅助存储空间，堆排序需要有一个堆的数据结构，前两者都比快速排序在某些程度上慢，所以
         * 当需要最短的排序时间时经常选择快速排序。
         *      然而，快速排序在处理非随机性数据时性能不大可靠，因为那时它的速度有可能蜕化至O(N^2)级。
         *      对于那些有可能是非随机性的数据来说，堆排更加可靠。当快速排序没有被正确地实现时.它会产生微小偏
         * 差。在代码中细小的错误会使它对按某些顺序排列的数据无能为力，而诊断到这种情况却又相当难。
         *      下表总结了不同排序算法的运行时间。在比较那一列中尝试对具有相同的平均时间复杂度的排序算法间的
         * 细微速度差别进行比较。（希尔排序没有比较，因为没有其他的算法与之有相同的大O性能级别。)
         *
         * 排序算法的比较
         *      下表用大O表示法总结了不同的通用数据存储结构的速度。
         *          排序          平均情况        最坏情况        比较         附加存储
         *  ------------------------------------------------------------------
         *          冒泡排序       O(N^2)         O(N^2)         及格         不需要
         *          选择排序       O(N^2)         O(N^2)         良好         不需要
         *          插入排序       O(N^2)         O(N^2)         优良         不需要
         *          希尔排序       O(N^3/2)       O(N^3/2)       ——           不需要
         *          快速排序       O(NlogN)       O(N^2)         优良         不需要
         *          归并排序       O(NlogN)       O(NlogN)       良好         需要
         *          堆排          O(NlogN)        O(NlogN)      良好         不需要
         *  ------------------------------------------------------------------
         *
         * 图
         *      图在数据存储结构的神殿（pantheon)中与众不同。它们并不存储通用数据，也并不会在其他算法中成为
         * 程序员的工具，正相反，它们直接模拟现实世界的情况。图的结构直接反映了问题的结构。
         *      当需要用图时，没有其他的数据结构可以取代之，所以对于何时选择图并没有太多可说的。主要的选择还
         * 是如何表示图：使用邻接矩阵或邻接表。这个选择依赖于图的疏密程度，稠密的图用邻接矩阵，稀疏的图用邻接
         * 表。
         *      邻接矩阵表示的图的深度优先搜索和广度优先搜索的时间复杂度为O(V^2)级，V是顶点的个数。 邻接表表
         * 示的图的这两种操作的时间复杂度为O(V+E)级，E是边的条数。最小生成树和最短路径在使用邻接矩阵表示时为
         * O(V^2)级，邻接表为O((E+V)logV)级。请先估计图中的V和E，并通过计算来判断哪种表示方法更加合适。
         *
         * 外部存储
         *      在先前的讨论中，我们假设了数据被存放在内存中。然而如果数据量大到内存容不下时，只能被存到外部存
         * 储空间，它们经常被称为磁盘文件。在第10章的第二部分“2-3-4树和外部存储”和 第11章“哈希表”中讨论了外部
         * 存储。
         *      存在磁盘文件中具有固定大小单元的数据被称为块（block),每一个块都存储一定数量的记录。 (磁盘文件
         * 中的记录拥有与主存中对象相同的数据类型。）与对象一样，每条记录都有一个关键字值。通过它可以访问到这条
         * 记录。
         *      同样，我们假设了读写操作总是在一个单一的块中进行，这些读写操作比对主存中的数据进行任何操作都要
         * 耗时得多。因此，为了提高操作速度必须将磁盘的存取次数减到最小。
         *
         * 顺序存储
         *      通过特定的关键字进行搜索的最简单的方法是随机存储记录然后顺序读取。新的记录可以被简单地插入在文
         * 件的最后。已删除的记录可以标记为己删除，或将记录顺次移动(如同数组中)来填补空缺。
         *      就平均而言，査找和删除会涉及读取半数的块，所以顺序存储并不很快，时间复杂度为O(N)。 但是对于小
         * 量数据来说它仍然是令人满意的。
         *
         * 索引文件
         *      当使用索引文件时，速度会明显的提高。在这种方法中关键字的索引和相应块的号数被存放在内存中。当通
         * 过一个特殊的关键字访问一条记录时，程序会先向索引询问。索引提供这个关键字的块号数，然后只需要读取这一
         * 个块，仅耗费了O(1)级的时间。
         *      可以使用不同种类的关键字来做多种索引（名字做一个，社会安全号码做一个，等等）。只要索引数量能在
         * 内存的存储的范围之内，这种方法表现得很好。
         *      通常，索引文件存储在磁盘上，只有在需要时才复制进内存中。
         *      索引文件的缺点是必须先创建索引，这有可能对磁盘上的文件进行顺序读取，所以创建索引是很慢的。同样，
         * 当记录被加入到文件中时，索引还需要更新。
         *
         * B-树
         *      B-树是多叉树，通常用于外部存储，树中的节点对应于磁盘中的块。同其他树一样，通过算法来遍历树，在
         * 每一层上读取一个块。B-树可以在O(logN)级的时间内进行査找、插入和删除。这是相当快的，并且它对很大的文
         * 件也很有效。但是，它的编程很繁琐。
         *
         * 哈希方法
         *      如果可以占用一个文件通常大小两倍以上的外部存储空间的话，外部哈希会是一个很好的选择。它同索引文
         * 件一样有着相同的存取时间，O(1)，但它可以对更大的文件进行操作。
         *      下图形象地表示了如何选择外部存储结构：
         *
         * ------------------------------------------------------------------------------
         *                                  不是
         *        开始   →    速度是否重要     →      顺序查找
         *
         *                       ↓是
         *
         *                   速度是否        不是
         *                   为决定性         →       B-树
         *                   因素?
         *
         *                       ↓是
         *
         *                   是否需要         是
         *                   附加存储         →       外部哈希
         *                   空间?
         *
         *
         *                      ↓不是
         *
         *                    索引文件
         *-----------------------------------------------------------------------------------
         *
         * 虚拟内存
         *      有时可以通过操作系统的虚拟内存的能力(如果它有的话)来解决磁盘存取问题，而不需通过编程。
         *      如果读取一个大小超过主存的文件，虚拟内存系统会读取合适主存大小的部分并将其他存储在磁盘上。当访问
         * 文件的不同部分时，它们会自动从磁盘读入并放置于内存中。
         *      可以对整个文件使用内部存储的算法，使它们好像同时都在内存中一样：如果文件的那个部分不在内存中，也
         * 让操作系统去读取它们。
         *      当然，这样的操作比整个文件在内存中的速度要慢得多，但是通过外部存储算法一块一块地处理文件的话，速
         * 度也是一样的慢。不要在乎文件的大小适合放在内存中，在虚拟内存的帮助下验证算法工作得好坏是有益的，尤其是
         * 对那些比可用的内存大不了多少的文件来说，这更是一个简单的解决方案。
         *
         * 前进
         *      至此，我们到达了对数据结构和算法探索旅程的终点。这个题目很大而且很复杂，没有哪一本书可以让你成为
         * 专家，但我们希望本书可以使你学习基础知识更加容易一些。
         *
         *
         *
         *
         */
    }
}
