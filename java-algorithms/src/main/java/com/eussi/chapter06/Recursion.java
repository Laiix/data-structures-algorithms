package com.eussi.chapter06;

import com.eussi.chapter06.util.Anagram;
import com.eussi.util.Util;

/**
 * @author wangxueming
 * @create 2019-11-12 21:23
 * @description
 */
public class Recursion {
    public static void main(String[] args) {
        /**
         * 递归
         *      递归是种方法(函数)调用自己的编程技术。这听起来似乎有点奇怪,或者甚至像是一个灾难
         * 性的错误。但是递归在编程中却是最有趣,又有惊人高效的技术之一。就像拽着自己的鞋带拔高一
         * 样,在第一次遇到递归时,它似乎让人觉得难以置信。然而,递归不仅可以解决特定的问题,而且它也
         * 为解决很多问题提供了一个独特的概念上的框架。
         *
         * 三角数字
         *      据说毕达哥拉斯理论家,又称一群在毕达哥拉斯(以毕达哥拉斯理论闻名)领导下工作的古希
         * 腊的数学家,发现了在数字序列1,3,6,10,15,21,...(省略号说明这个序列无限地继续下去)
         * 中有一种奇特的联系。你能知道这个序列的下一个数字是什么吗?
         *      这个数列中的第n项是由第n-1项加n得到的。由此,第二项是由第一项(1)加上2,得3。
         * 第三项是由第二项(3)加上3得到6,依此类推
         *      这个序列中的数字被称为三角数字，因为他们可以被形象化的表示成对象的一个三角形排列：
         *                                        *
         *                            *           * *
         *               *            * *         * * *
         *      *        * *          * * *       * * * *
         *     n=1       n=2           n=3          n=4
         *   即：f(n)= (1+n)*n/2 = (n^2+n)/2
         *
         * 首先，可以使用循环查找第n项：
         */
        System.out.println(triangle(3));
        Util.printDivide();
        /**
         * 使用递归查找第n项：
         *      循环的方法好像是非常易懂的,但是还可以通过另外一种方式来看这个问题。第n项的值可以
         * 被看成只是两个部分的和,而不是被看作整个序列的和。它们是:
         *      1.第一列(最高的一列),它的值为n。
         *      2.所有剩余列的和。
         * 把责任推给别人
         *      所有的这些方法都可以看作是把责任推给别人。某人让我计算第九个三角数字。我知道这就是
         * 9加上第八个三角数字,所以我叫来Hary并让他来计算第八个三角数字。当我从Hary那里得到
         * 了返回的时候,我就可以用9去加上他告诉我的结果了,并且这就是我的答案了。
         *      Harry知道第八个三角数字是8加上第七个三角数字所得到的结果,所以他找到 Sally,并且让
         * Sally去求第七个三角数字。这个过程持续不断地把问题从一个人这里传递到另一个人那里
         *      什么地方是这个传递的终结呢?在这个地方的人必须不再需要得到另外一个人的帮助就能够
         * 计算出结果。如果这种情况没有发生,那么就会有一个无限的一个人要求另外一个人的链——这是一
         * 种算法的庞氏骗局( Ponzi scheme),它将永远不会结束。在 triangle()方法中目前的情况,意味着
         * 调用自身的方法反复地无限执行,最终它将会使这个程序崩溃。
         * 不推卸责任
         *      为了防止无限重复调用自身的过程,在序列中第一个找到三角数字的人,也就是当n等于1时,
         * 他肯定知道结果是1,没有更小的数字需要询问别人了,也没有什么数字可以去加到其他的数字上
         * 了,所以到此为止不再推卸责任。可以给 triangle方法增加一个条件来表示
         */
        System.out.println(triangle1(3));
        Util.printDivide();
        /**
         * 注意，在最内层方法返回1之前，实际上在同一时刻有3个不同的triangle1()方法的实例。
         *
         * 递归方法的特征：
         *      尽管 triangle1方法很短,但是它拥有所有递归算法都具备的关键特征：
         *          调用自身。
         *          当它调用自身的时候,它这样做是为了解决更小的问题。
         *          存在某个足够简单的问题的层次,在这一层算法不需要调用自己就可以直接解答,且返结果。
         *      在递归算法每次调用自身的过程中,参数变小(也许是被多个参数描述的范围变小),这反映
         * 了问题变小或变简单的事实。当参数或者范围达到一定的最小值时,将会触发一个条件,此时方法
         * 不需要调用自身而可以返回。
         *
         * 递归方法有效率吗?
         *      调用一个方法会有一定的额外开销。控制必须从这个调用的位置转移到这个方法的开始处。除
         * 此之外,传给这个方法的参数以及这个方法返回的地址都要被压入到一个内部的栈里,为的是这个
         * 方法可以访问参数值和知道返回到哪里。
         *      就 triangle1这个方法来讲,因为有上述开销而造成的结果,可能 while循环方法执行的速度比
         * 递归的方法快。在此题中,递归的代价也许不算太大。但是如果由于递归方法的存在,造成了太大
         * 规模的方法调用的话,可能会考虑消除递归,在这一章的最后将会详谈一些这方面的问题。
         *      另外一个低效性反映在系统内存空间存储所有的中间参数以及返回值,如果有大量的数据需要
         * 存储，就会引起栈溢出的问题。
         *      人们常常采用递归，是因为它从概念上简化了问题，而不是因为它本质上更有效率。
         */

        /**
         * 数学归纳法
         *      递归就是程序设计中的数学归纳法。数学归纳法是一种通过自身的语汇定义某事物自己的方
         * 法。(语汇也被用于描述证明原理的相关方法。)使用归纳法,可以用数学的方式定义三角数字
         *      tri(n=1)             if n=1
         *      tri(n)=n+tri(n-1)    if n> 1
         *      用自身来定义某事可能看起来是在转圈子,但是事实上它是完全正确的(假设有一个基值情
         * 况)。
         */

        /**
         * 阶乘
         *      计算阶乘是一个递归的经典例子,尽管阶乘不像三角数字那
         * 么直观
         *      其他很多数字学的问题都使用递归的类似方法解决,比如找
         * 两个数的最大公约数(用于分数化简),求一个数的乘方,等等。
         *      再说一次,尽管这些计算可以很好地说明递归,但是它们不太可
         * 能用于实际,因为基于循环的方法效率更高。
         */
        System.out.println(factorial(3));
        Util.printDivide();

        /**
         * 全排列单词：
         *      1、全排列最右边的n-1个字母
         *      2、轮换所有n个字母
         *      3、重复以上步骤 n次
         *
         */
        doAnagram();
        Util.printDivide();


    }

    public static void doAnagram() {
        Anagram anagram = new Anagram("cat");
        anagram.doExecute();
    }

    public static int factorial(int n)
    {
        System.out.println("calculate " + n);
        if(n==1) {
            System.out.println("Returning 1");
            return 1;
        }
        else {
            int temp = n * factorial(n-1);
            System.out.println("Returning " + temp);
            return temp;
        }
    }

    /**
     * 递归调用
     * @param n
     * @return
     */
    public static int triangle1(int n)
    {
        System.out.println("calculate " + n);
        if(n==1) {
            System.out.println("Returning 1");
            return 1;
        }
        else {
            int temp = n + triangle1(n-1);
            System.out.println("Returning " + temp);
            return temp;
        }
    }

    /**
     * 循环调用
     * @param n
     * @return
     */
    public static int triangle(int n) {
        int total = 0;
        while(n>0) {
            total += n;
            --n;
        }
        return total;
    }
}
