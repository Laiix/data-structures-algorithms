package com.eussi.ch12_heap;

import com.eussi.ch12_heap.util.Heap;
import com.eussi.util.Util;

import java.io.IOException;

/**
 * @author wangxueming
 * @create 2020-03-03 21:33
 * @description
 */
public class HeapApp {
    /**
     * 堆
     *      第4章中介绍了优先级队列,它是一种对最小(或最大)关键字的数据项提供便利访问
     * 的数据结构。
     *      优先级队列可以用于计算机中的任务调度,在计算机某些程序和活动需要比其他的程
     * 序和活动先执行,因此要给它们分配更高的优先级。
     *      另一个例子是在武器系统中,比如在一个海军巡洋舰系统中。会探测到许多对巡洋舰
     * 的威胁,如来自飞机、导弹、潜水艇等的攻击,需要为这些威胁分优先级。例如,离巡洋舰距
     * 离近的导弹就比距离远的飞机的优先级更高,这样对应的防范系统(例如地对空导弹)会首先
     * 对付它。
     *      优先级队列也可以用在其他计算机算法的内部。在第14章中,可以看到图算法中应用了
     * 优先级队列,例如在 Dijkstra算法中。
     *      优先级队列是一个抽象数据类型(ADT),它提供了删除最大(或最小)关键字值的数据项的
     * 方法,插入数据项的方法,有时还有一些其他操作的方法。配合不同的ADT,优先级队列可以用不
     * 同的内部结构来实现。第4章中可以看到,优先级队列是用有序数组来实现的。这种作法的问题是
     * 尽管删除最大数据项的时间复杂度为O(1),但是插入还是需要较长的O(N)时间。这是因为必须移
     * 动数组中平均一半的数据项以插入新数据项,并在完成插入后,数组依然有序。
     *      本章将介绍实现优先级队列的另一种结构:堆。堆是一种树,由它实现的优先级队列的插入和
     * 删除的时间复杂度都是O(logN)。尽管这样删除的时间变慢了一些,但是插入的时间快得多了。当
     * 速度非常重要,且有很多插入操作时,可以选择堆来实现优先级队列。
     *
     * 注意
     *      这里的“堆”是指一种特殊的二叉树,不要和Java和C++等编程语言里的“堆”混淆,后者指
     * 的是程序员用new能得到的计算机内存的可用部分。
     */
    public static void main(String[] args) {
        /**
         * 堆的介绍
         *      堆是有如下特点的二叉树
         *       - 它是完全二叉树。这也就是说,除了树的最后一层节点不需要是满的,其他的每一层从左
         * 到右都完全是满的。图121显示了完全二叉树和非完全二叉树。
         *       - 它常常用一个数组实现。第8章中介绍了如何用数组而不是由引用连接起来的各个节点来
         * 存储二叉树
         *       - 堆中的每一个节点都满足堆的条件,也就是说每一个节点的关键字都大于(或等于)这个
         * 节点子节点的关键字。
         *      堆在存储器中表示的是数组，堆只是概念上的一个表示。注意树是完全二叉树，并且所有的
         * 节点都满足堆的条件。
         *      堆是完全二叉树的事实说明了表示堆的数组中没有“洞”，从下标0到N-1,每一个数据单元都
         * 有数据项。
         *      本章中假设的最大的（而不是最小的）关键字在根节点上。基于这种堆的优先级队列是降序
         * 的优先级队列。
         *
         * 优先级队列、堆和抽象数据类型(ADT)
         *      本章讨论堆,堆主要用于实现优先级队列,优先级队列和实现它的堆之间有非常紧密的关系。
         *      优先级队列是一个可以用不同的方法实现的ADT,而堆是一种更为基础的数据结构。在本章中,
         * 为了简单起见,用的是没有封装在优先级队列中的堆的方法。
         *
         * 弱序
         *      堆和二叉搜索树相比是弱序的,在二叉搜索树中所有节点的左子孙的关键字都小于右子孙的关
         * 键字。这说明在一个二叉搜索树中通过一个简单的算法就可以按序遍历节点,正如以前看到的那样。
         *      在堆中,按序遍历节点是困难的,这是因为堆的组织规则(堆的条件)比二叉搜索树的组织规
         * 则弱。对于堆来说,只要求沿着从根到叶子的每一条路径,节点都是按降序排列的。指定节点的左边
         * 节点或者右边节点,以及上层节点或者下层节点由于不在同一条路径上,它们的关键字可能比指定节
         * 点的关键字或大或小。除了有共享节点的路径,路径之间都是相互独立的。
         *      由于堆是弱序的,所以一些操作是困难的或者是不可能的。除了不支持遍历以外,也不能在堆
         * 上便利地查找指定关键字,因为在查找的过程中,没有足够的信息来决定选择通过节点的两个子节
         * 点中的哪一个走向下一层。它也不能在少至O(logN)的时间内删除一个指定关键字的节点,因为没
         * 有办法能找到这个节点。(这些操作可以通过按顺序查找数组的每一个单元来执行,但是只能以较
         * 慢的O(N)时间执行。)
         *      因此,堆的这种组织似乎非常接近无序。不过,对于快速移除最大节点的操作以及快速插入新
         * 节点的操作,这种顺序已经足够了。这些操作是使用堆作为优先级队列时所需的全部操作。后面将
         * 主要讨论这些操作是如何完成的。
         *
         * 移除
         *      移除是指删除关键字最大的节点。这个节点总是根节点,所以移除是很容易的。根在堆数组中
         * 的索引总是0
         *      maxNode = heapArray[0]
         *      问题是一旦移除了根节点,树就不再是完全的了;数组里就有了一个空的数据单元。这个“洞
         * 必须要填上,可以把数组中所有数据项都向前移动一个单元,但是还有快得多的方法。下面就是移
         * 除最大节点的步骤:
         *      1.移走根
         *      2.把最后一个节点移动到根的位置。
         *      3.一直向下筛选这个节点,直到它在一个大于它的节点之下,小于它的节点之上为止。
         *      最后一个节点(last)是树最低层的最右端的数据项,它对应于数组中最后一个填入的数据单元。
         * 把这个节点直接复制到根节点处
         *      heapArray[0] = heapArray[N-1];
         *      N--;
         *      移除了根,使数组容量的大小减一
         *      向上或向下“筛选”(也可以用“冒泡”或者“渗滤”)一个节点是指沿着一条路径一步一步地
         * 移动此节点,和它前面的节点交换位置,每一步都检查它是否处在了合适的位置。在步骤3中,在
         * 根上的节点对根来说太小了,所以要把它筛选到堆的合适的位置。后面将看到它的代码。
         *      步骤2恢复了堆的完全性的特征(没有洞),而步骤3恢复了堆的条件(每个节点都大于它的
         * 子节点)。
         *      在被筛目标节点的每个暂时停留的位置上,向下筛选的算法都要检查哪一个子节点更大。然后
         * 目标节点和较大的子节点交换位置。如果要把目标节点和较小的子节点换位,那么这个子节点就会变
         * 成大子节点的父节点,这就违背了堆的条件，下图显示了正确的和不正确的交换情况：
         *                          30
         *                        /    \
         *                      63     70
         *
         *                63                    70
         *       错误：  /   \(此处63<70)       /   \   :正确
         *             30   70                63   30
         *
         *
         * 插入
         *      插入节点也是很容易的。插入使用向上筛选,而不是向下筛选。节点初始时插入到数组最后第
         * 一个空着的单元中,数组容量大小增一。
         *      heapArray[N] = newNode
         *      N++
         *      问题是这样可能会破坏堆的条件。如果新插入的节点大于它新得到的父节点时,就会发生这种
         * 情况。因为父节点在堆的底端,它可能很小,所以新节点就显得比较大。因此,需要向上筛选新节
         * 点,直到它在一个大于它的节点之下,在一个小于它的节点之上。
         *      向上筛选的算法比向下筛选的算法相对简单,因为它不用比较两个子节点的关键字大小。节点
         * 只有一个父节点,目标节点只要和它的父节点换位即可。
         *      另外，如果先移除一个节点再插入相同的一个节点,结果并不一定是恢复为原来的堆。一组给
         * 定的节点可以组成很多合法的堆,这取决于节点插入的顺序
         *
         * 不是真的交换
         *      换位是在概念上理解插入和删除最简单的方法,并且实际上某些堆的实现也确实使用了换位。
         * 下面左图显示了在向下筛选的过程中使用换位的简化版本。在三次换位之后,节点A将停在D的位置上,并且
         * 节点B、C和D都会向上移动一层。
         *                    A                        A
         *                   /                        /
         *                  B                        B     \
         *                 /                        /       temp
         *                C                        C      /
         *               /                        /     /
         *              D                        D
         *      但是,一次交换需要三次复制,因此在上面左图所示的三次交换中就需要九次复制。通过在
         * 筛选的算法中使用复制取代交换,可以减少所需的复制总数
         *      上面右图显示了如何用五次复制做三次换位。首先,暂时保存节点A:然后B覆盖A,C覆盖
         * B,D覆盖C:最后,再从临时存储中取出A复制到以前D的位置上。这样就把复制的次数从九次
         * 减少到了五次
         *      在图中节点A移动了三层。当层数增加时,复制节省的时间更多,因为从临时存储区复制以及
         * 复制到临时存储区的两次复制在复制的总数中所占的比例更少了。对于很多层的堆,节省的复制次
         * 数接近三的倍数
         *      另一种观察用复制执行向上筛选和向下筛选过程的方法是用“洞”的思想(空节点的数组元素
         * 单元),在向上筛选时洞向下移动,向下筛选时洞向上移动。例如,上面右图中把A复制到Temp中,
         * 在A点创建一个“洞”。“洞”实际上保留着被移走节点原来的值,它还在那,但这没关系。把B
         * 复制到A,“洞”由A移动到B,和节点位置的变化方向相反。“洞”一步一步地向下移动。
         *
         * 堆的Java代码
         *      下面是第8章中关于用数组表示一棵树的一些要点。若数组中节点的索引为x,则
         *       - 它的父节点的下标为(x-1)/2
         *       - 它的左子节点的下标为2*x+1。
         *       - 它的右子节点的下标为2*x+2。
         * 数组的大小
         *      应该注意,数组的大小,也就是记录堆中节点的数目,是Heap类中关于堆状态的一个很重要
         * 的信息,也是Heap类中关键的字段。从最后一个位置复制的节点并不清除,所以对于算法来说,
         * 判断最后一个堆占用单元位置的惟一方法是根据数组当前的大小求得。
         */
        TestHeap();
        Util.printSeparator();
    }

    public static void TestHeap() {
        int value, value2;
        Heap theHeap = new Heap(31);  // make a HeapApp; max size 31
        boolean success;

        theHeap.insert(70);           // insert 10 items
        theHeap.insert(40);
        theHeap.insert(50);
        theHeap.insert(20);
        theHeap.insert(60);
        theHeap.insert(100);
        theHeap.insert(80);
        theHeap.insert(30);
        theHeap.insert(10);
        theHeap.insert(90);

        theHeap.displayHeap();

        int key = 11;
        System.out.println("Enter value to insert: " + key);
        success = theHeap.insert(key);
        if( !success )
            System.out.println("Can't insert; heap full:" + key);
        theHeap.displayHeap();

        key = 12;
        System.out.println("Enter value to insert: " + key);
        success = theHeap.insert(key);
        if( !success )
            System.out.println("Can't insert; heap full:" + key);
        theHeap.displayHeap();

        if( !theHeap.isEmpty() ) {
            System.out.println("remove:" + theHeap.remove());
            theHeap.displayHeap();
        } else
            System.out.println("Can't remove; heap empty");

        if( !theHeap.isEmpty() ) {
            System.out.println("remove:" + theHeap.remove());
            theHeap.displayHeap();
        } else
            System.out.println("Can't remove; heap empty");


        key = 8;
        int newKey = 200;
        System.out.println("Enter current index of item: " + key);
        System.out.println("Enter new key: " + newKey);
        success = theHeap.change(key, newKey);
        if( !success )
            System.out.println("Invalid index");
        else
            theHeap.displayHeap();

        key = 0;
        newKey = 3;
        System.out.println("Enter current index of item: " + key);
        System.out.println("Enter new key: " + newKey);
        success = theHeap.change(key, newKey);
        if( !success )
            System.out.println("Invalid index");
        else
            theHeap.displayHeap();
    }  // end main()
}
